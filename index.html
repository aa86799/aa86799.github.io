<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>stone的安卓世界</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="人生不是简单的if和else，很多时候都是在出现问题时才when and then">
<meta property="og:type" content="website">
<meta property="og:title" content="stone的安卓世界">
<meta property="og:url" content="http://aa86799.github.io/index.html">
<meta property="og:site_name" content="stone的安卓世界">
<meta property="og:description" content="人生不是简单的if和else，很多时候都是在出现问题时才when and then">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="stone的安卓世界">
<meta name="twitter:description" content="人生不是简单的if和else，很多时候都是在出现问题时才when and then">
  
    <link rel="alternate" href="/atom.xml" title="stone的安卓世界" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">stone的安卓世界</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">打鱼还是晒网 —— stone</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://aa86799.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-ThreadPoolExecutor分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/06/ThreadPoolExecutor分析/" class="article-date">
  <time datetime="2017-05-06T09:40:33.000Z" itemprop="datePublished">2017-05-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/06/ThreadPoolExecutor分析/">ThreadPoolExecutor 线程池调度器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="可设置的主要参数"><a href="#可设置的主要参数" class="headerlink" title="可设置的主要参数"></a>可设置的主要参数</h1><ul>
<li>corePoolSize</li>
</ul>
<p>核心线程数，核心线程会一直存活，即使没有任务需要处理。当线程数小于核心线程数时，即使现有的线程空闲，线程池也会优先创建新线程来处理任务，而不是直接交给现有的线程处理。</p>
<p>核心线程在allowCoreThreadTimeout被设置为true时会超时退出，默认情况下不会退出。</p>
<ul>
<li>maxPoolSize</li>
</ul>
<p>当线程数大于或等于核心线程，且任务队列已满时，线程池会创建新的线程，直到线程数量达到maxPoolSize。如果线程数已等于maxPoolSize，且任务队列已满，则已超出线程池的处理能力，线程池默认会拒绝处理任务而抛出异常。可以自定义处理多余任务的RejectedExecutionHandler</p>
<p>该参数在某些情况下是无效的。</p>
<ul>
<li>keepAliveTime</li>
</ul>
<p>当已经执行过的线程空闲后，空闲时间小于keepAliveTime，又来了新的任务时，会直接启动该线程。</p>
<p>当线程空闲时间达到keepAliveTime，该线程会退出，直到线程数量等于corePoolSize。</p>
<p>如果allowCoreThreadTimeout设置为true，则所有线程均会退出直到线程数量为0。</p>
<ul>
<li>allowCoreThreadTimeout</li>
</ul>
<p>是否允许核心线程空闲退出，默认值为false。</p>
<ul>
<li>queueCapacity</li>
</ul>
<p>任务队列容量，由它设定一个有界的队列。从maxPoolSize的描述上可以看出，任务队列的容量会影响到线程的变化，因此任务队列的长度也需要恰当的设置。</p>
<ul>
<li><p>RejectedExecutionHandler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>任务拒绝处理策略。在源码中定义了如下几种策略：</p>
<ul>
<li><p>AbortPolicy (默认策略)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicy</span><span class="params">()</span> </span>&#123; &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Task "</span> + r.toString() +</div><div class="line">                                                 <span class="string">" rejected from "</span> +</div><div class="line">                                                 e.toString());</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>该策略 直接抛出了异常。异常中止</p>
</li>
<li><p>CallerRunsPolicy</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CallerRunsPolicy</span><span class="params">()</span> </span>&#123; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</div><div class="line">            r.run();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在线程池未关闭时，直接在当前线程执行任务。所谓当前线程，即提交任务时的线程</p>
</li>
<li><p>DiscardPolicy</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardPolicy</span><span class="params">()</span> </span>&#123; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不做任何处理，即跳过任务r</p>
</li>
<li><p>DiscardOldestPolicy</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardOldestPolicy</span><span class="params">()</span> </span>&#123; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</div><div class="line">            e.getQueue().poll();</div><div class="line">            e.execute(r);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在线程池未关闭时，移除处于队头的任务，再执行任务r。相当于把之前队头的任务跳过了，把r又加入了队列</p>
<p>​</p>
<p>​</p>
</li>
</ul>
</li>
</ul>
<h1 id="参数对线程池任务调度的影响"><a href="#参数对线程池任务调度的影响" class="headerlink" title="参数对线程池任务调度的影响"></a>参数对线程池任务调度的影响</h1><p>当任务数大于等于corePoolSize，这时，除核心线程执行了一定数量的任务后，</p>
<p>余下的需要执行的任务数为<code>int count = tasksCount - corePoolSize</code>，设队列最大容量为capacity：</p>
<ul>
<li><p>若<code>capacity &gt;= count</code>，则只会创建corePoolSize个线程来执行任务。多的任务放在队列中。</p>
<p>这时maxPoolSize，就无效了</p>
</li>
<li><p>若<code>capacity &lt; count</code>，这时有<code>int remain = tasksCount - capacity</code>：</p>
<ul>
<li>若 <code>remain &lt;= maxPoolSize</code>，创建remain个线程来执行任务。多的任务放在队列中</li>
<li>若<code>remain &gt; maxPoolSize</code>，创建maxPoolSize个线程来执行任务；这时将有<code>remain-maxPoolSize</code>个任务无法加入队列，被RejectedExecutionHandler处理。</li>
</ul>
<p>​</p>
</li>
</ul>
<h1 id="Executors生成ThreadPoolExecutor"><a href="#Executors生成ThreadPoolExecutor" class="headerlink" title="Executors生成ThreadPoolExecutor"></a>Executors生成ThreadPoolExecutor</h1><p><a href="http://dongxuan.iteye.com/blog/901689" target="_blank" rel="external">(most from http://dongxuan.iteye.com/blog/901689)</a></p>
<p>在构建时，corePoolSize、maximumPoolSizes 和BlockingQueue的选择，直接影响线程调度的策略</p>
<p>Executors 有三个方法可以生成 ThreadPoolExecutor</p>
<h2 id="生成一个固定线程数的-ThreadPoolExecutor"><a href="#生成一个固定线程数的-ThreadPoolExecutor" class="headerlink" title="生成一个固定线程数的 ThreadPoolExecutor"></a>生成一个固定线程数的 ThreadPoolExecutor</h2><p>public static ExecutorService newFixedThreadPool(int nThreads) {</p>
<p>​    return new ThreadPoolExecutor(nThreads, nThreads,</p>
<p>​                                  0L, TimeUnit.MILLISECONDS,</p>
<p>​                                  new LinkedBlockingQueue<runnable>());</runnable></p>
<p>}</p>
<p>LinkedBlockingQueue实现是线程安全的，实现了先进先出等特性，是作为生产者消费者的首选，LinkedBlockingQueue 可以指定容量，也可以不指定，不指定的话，默认最大是Integer.MAX_VALUE，其中主要用到put和take方法，put方法在队列满的时候会阻塞直到有队列成员被消费，take方法在队列空的时候会阻塞，直到有队列成员被放进来。在ThreadPoolExecutor中主要使用的是BlockingQueue的offer()和 poll()、take()</p>
<p>LinkedBlockingQueue 无界队列</p>
<h2 id="生成一个只含一个线程的ThreadPoolExecutor"><a href="#生成一个只含一个线程的ThreadPoolExecutor" class="headerlink" title="生成一个只含一个线程的ThreadPoolExecutor"></a>生成一个只含一个线程的ThreadPoolExecutor</h2><p>public static ExecutorService newSingleThreadExecutor() {  </p>
<p>​    return new FinalizableDelegatedExecutorService  </p>
<p>​        (new ThreadPoolExecutor(1, 1,  </p>
<p>​                                0L, TimeUnit.MILLISECONDS,  </p>
<p>​                                new LinkedBlockingQueue<runnable>()));  </runnable></p>
<p>} </p>
<p>LinkedBlockingQueue 无界队列 </p>
<h2 id="生成一个无界的并直接提交的ThreadPoolExecutor"><a href="#生成一个无界的并直接提交的ThreadPoolExecutor" class="headerlink" title="生成一个无界的并直接提交的ThreadPoolExecutor"></a>生成一个无界的并直接提交的ThreadPoolExecutor</h2><p>public static ExecutorService newCachedThreadPool() {  </p>
<p>​    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,  </p>
<p>​                                  60L, TimeUnit.SECONDS,  </p>
<p>​                                  new SynchronousQueue<runnable>());  </runnable></p>
<p>}  </p>
<p>这个线程池根据需要（新任务到来时）创建新的线程，如果有空闲线程则会重复使用，线程空闲了60秒后会被回收</p>
<p>SynchronousQueue 的特点是，每个插入操作必须等待另一个线程的对应移除操作。比如，要添加一个元素，接下来如果继续想尝试添加则会阻塞，直到另一个线程取走一个元素，反之亦然</p>
<p>SynchronousQueue 不会保留任务进队列，会直接提交到工作线程。</p>
<p>如果当前没有可工作线程，那么在 corePoolSize&lt;maxPoolSize时，会直接创建出新的线程以执行任务</p>
<p>SynchronousQueue 直接提交策略</p>
<h1 id="关于工作队列-workQueue-："><a href="#关于工作队列-workQueue-：" class="headerlink" title="关于工作队列(workQueue)："></a>关于工作队列(workQueue)：</h1><p>所有 BlockingQueue 都可用于传输和保持提交的任务。可以使用此队列与池大小进行交互： </p>
<ul>
<li>如果运行的线程少于 corePoolSize，则 Executor 始终首选添加新的线程，而不进行排队。（什么意思？如果当前运行的线程小于corePoolSize，则任务根本不会存放，添加到queue中，而是直接开始运行thread。</li>
<li>如果运行的线程等于或多于 corePoolSize，则 Executor 始终首选将请求加入队列，而不添加新的线程。 </li>
<li>如果无法将请求加入队列，则创建新的线程，除非创建此线程超出 maximumPoolSize，在这种情况下，任务将被拒绝。</li>
</ul>
<h2 id="排队有三种通用策略："><a href="#排队有三种通用策略：" class="headerlink" title="排队有三种通用策略："></a>排队有三种通用策略：</h2><ol>
<li><p>直接提交。工作队列的默认选项是 SynchronousQueue，它将任务直接提交给线程而不保持它们。在此，如果不存在可用于立即运行任务的线程，则试图把任务加入队列将失败，因此会构造一个新的线程。此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。直接提交通常要求无界 maximumPoolSizes 以避免拒绝新提交的任务。当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。 </p>
</li>
<li><p>无界队列，即队列容量超出余下任务量。使用无界队列（例如，不具有预定义容量的 LinkedBlockingQueue）将导致在所有 corePoolSize 线程都忙时新任务在队列中等待。这样，创建的线程就不会超过 corePoolSize。（因此，maximumPoolSize 的值也就无效了。）当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列；例如，在 Web 页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。</p>
</li>
<li><p>有界队列，即队列容量小于余下任务量。当使用有限的 maximumPoolSizes 时，有界队列（如 ArrayBlockingQueue或具有预定义容量的 LinkedBlockingQueue）有助于防止资源耗尽，但是可能较难调整和控制。队列大小和最大池大小可能需要相互折衷：使用大型队列和小型池可以最大限度地降低 CPU 使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。如果任务频繁阻塞（例如，如果它们是 I/O 边界），则系统可能为超过您许可的更多线程安排时间。使用小型队列通常要求较大的池大小，CPU 使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量。</p>
<p>​</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://aa86799.github.io/2017/05/06/ThreadPoolExecutor分析/" data-id="cj7sppyhw0000yp9wq7egy87v" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-rxjava 1.x" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/02/rxjava 1.x/" class="article-date">
  <time datetime="2017-05-02T12:51:43.000Z" itemprop="datePublished">2017-05-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/02/rxjava 1.x/">RxJava1.x 你需要了解的</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="RxJava-1-x"><a href="#RxJava-1-x" class="headerlink" title="RxJava 1.x"></a>RxJava 1.x</h1><p><img src="images/whyuseobserver.png"></p>
<p>RxJava扩展了观察者模式的语义，添加了两个新的操作接口：  </p>
<ul>
<li>onCompleted() 通知观察者，Observable没有更多的数据了</li>
</ul>
<ul>
<li>onError() 观察到有错误出现了</li>
</ul>
<p>而<strong>onNext()</strong> 将被观察者生产的事件通知到观察者</p>
<h2 id="RxJava-1-x的四种基本角色"><a href="#RxJava-1-x的四种基本角色" class="headerlink" title="RxJava 1.x的四种基本角色"></a>RxJava 1.x的四种基本角色</h2><ul>
<li>Observable</li>
<li>Observer</li>
<li>Subscriber</li>
<li>Subject  </li>
</ul>
<p>其中，Observable和Subject是两个”生产”(被观察者)的实体，Observer和Subscriber是两个”消费”(观察者)的实体。其中Observable、Observer是两个基础角色。</p>
<p>Subscriber实现了Observer，并且还添加了一个<strong>onStart()</strong>，它会在 subscribe 刚开始，而事件还未发送之前被调用，可以用于做一些准备工作。</p>
<p>Subject = Observable + Observer</p>
<p>下图描述Subject与Observer的一对多关系：<br><img src="images/observer_subject.png"> </p>
<h2 id="Obsrvable的变种-——-Single"><a href="#Obsrvable的变种-——-Single" class="headerlink" title="Obsrvable的变种 —— Single"></a>Obsrvable的变种 —— Single</h2><p>Observable还有一个变种，就是<strong>Single</strong>，它总是只发射一个事件，或者一个错误通知</p>
<p>订阅<strong>Single</strong>只需要两个方法：</p>
<ul>
<li>onSuccess - <strong>Single</strong>发射单个的值到这个方法</li>
<li>onError - 如果无法发射需要的值，<strong>Single</strong>发射一个Throwable对象到这个方法</li>
</ul>
<blockquote>
<p>了解就行了，用法与Observable差不多</p>
</blockquote>
<h2 id="热的、冷的-Observables"><a href="#热的、冷的-Observables" class="headerlink" title="热的、冷的 Observables"></a>热的、冷的 Observables</h2><p><strong>热的</strong>：Observable只要一创建，就会立即开始emit(发射)数据。后续的订阅它的观察者，可能从序列中间的某个位置开始接受数据(有一些数据错过了)<br><strong>冷的</strong>：Observable创建后，一直在等待，直到有观察者订阅它才开始emit数据</p>
<h2 id="Subject-Observable-Observer"><a href="#Subject-Observable-Observer" class="headerlink" title="Subject = Observable + Observer"></a>Subject = Observable + Observer</h2><p>Subject，既是一个Observable，也是一个Observer。  可以emit数据，可以subscribe 一个Observable或其它Subject。  </p>
<p>RxJava 提供四种不同的 Subject:  </p>
<ul>
<li>PublishSubject</li>
<li>BehaviorSubject</li>
<li>ReplaySubject</li>
<li>AsyncSubject</li>
<li>UnicastSubject</li>
<li>SerializedSubject</li>
</ul>
<p>###PublishSubject<br>是Subject的一个子类，它通过<strong><em>create()</em></strong>创建实例。它是一个”冷的”Observable。直到触发它的onNext(T t)，才开始emit数据，并完成订阅。<br>可用于实现类似EventBus的RxBus。</p>
<p>###BehaviorSubject<br>是Subject的一个子类，它通过<strong><em>create()</em></strong>创建实例。首先会向它的订阅者发送截止订阅前的最后一条数据流，然后才正常发送订阅后的数据流。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="comment">// observer will receive all 4 events (including "default").</span></div><div class="line">  BehaviorSubject&lt;Object&gt; subject = BehaviorSubject.create(<span class="string">"default"</span>);</div><div class="line">  subject.subscribe(observer);</div><div class="line">  subject.onNext(<span class="string">"one"</span>);</div><div class="line">  subject.onNext(<span class="string">"two"</span>);</div><div class="line">  subject.onNext(<span class="string">"three"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// observer will receive the "one", "two" and "three" events, but not "default" and "zero"</span></div><div class="line">  BehaviorSubject&lt;Object&gt; subject = BehaviorSubject.create(<span class="string">"default"</span>);</div><div class="line">  subject.onNext(<span class="string">"zero"</span>);</div><div class="line">  subject.onNext(<span class="string">"one"</span>);</div><div class="line">  subject.subscribe(observer);</div><div class="line">  subject.onNext(<span class="string">"two"</span>);</div><div class="line">  subject.onNext(<span class="string">"three"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// observer will receive only onCompleted</span></div><div class="line">  BehaviorSubject&lt;Object&gt; subject = BehaviorSubject.create(<span class="string">"default"</span>);</div><div class="line">  subject.onNext(<span class="string">"zero"</span>);</div><div class="line">  subject.onNext(<span class="string">"one"</span>);</div><div class="line">  subject.onCompleted();</div><div class="line">  subject.subscribe(observer);</div><div class="line"></div><div class="line">  <span class="comment">// observer will receive only onError</span></div><div class="line">  BehaviorSubject&lt;Object&gt; subject = BehaviorSubject.create(<span class="string">"default"</span>);</div><div class="line">  subject.onNext(<span class="string">"zero"</span>);</div><div class="line">  subject.onNext(<span class="string">"one"</span>);</div><div class="line">  subject.onError(<span class="keyword">new</span> RuntimeException(<span class="string">"error"</span>));</div><div class="line">  subject.subscribe(observer);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="ReplaySubject"><a href="#ReplaySubject" class="headerlink" title="ReplaySubject"></a>ReplaySubject</h3><p>缓存订阅的数据，重发给订阅它的观察者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ReplaySubject&lt;String&gt; subject = ReplaySubject.create();</div><div class="line">subject.onNext(<span class="string">"haha1"</span>);</div><div class="line">subject.onNext(<span class="string">"haha2"</span>);</div><div class="line">subject.onNext(<span class="string">"haha3"</span>);</div><div class="line">subject.subscribe(s -&gt; System.out.println(<span class="string">"rss1"</span> + s));</div></pre></td></tr></table></figure>
<h3 id="AsyncSubject"><a href="#AsyncSubject" class="headerlink" title="AsyncSubject"></a>AsyncSubject</h3><p>仅在Observable完成之后，发送最后一条数据给观察者。</p>
<p>然而如果当Observable因为异常而终止，AsyncSubject将不会释放任何数据，但是会向Observer传递一个异常通知。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">AsyncSubject&lt;String&gt; subject = AsyncSubject.create();</div><div class="line">subject.onNext(<span class="string">"haha1"</span>);</div><div class="line">subject.onNext(<span class="string">"haha2"</span>);</div><div class="line">subject.onNext(<span class="string">"haha3"</span>);</div><div class="line">subject.onCompleted();</div><div class="line">subject.subscribe(s -&gt; System.out.println(<span class="string">"ass1"</span> + s));</div></pre></td></tr></table></figure>
<h3 id="UnicastSubject"><a href="#UnicastSubject" class="headerlink" title="UnicastSubject"></a>UnicastSubject</h3><p>只允许有一个 Subscriber 订阅(内部subscribeActual()，用到了AtomicBoolean 判断，第二次无就抛出异常)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">UnicastSubject subject = UnicastSubject.create();</div><div class="line">subject.onNext(<span class="string">"haha1"</span>);</div><div class="line">subject.onNext(<span class="string">"haha2"</span>);</div><div class="line">subject.onNext(<span class="string">"haha3"</span>);</div><div class="line">subject.onCompleted();</div><div class="line">subject.subscribe(s -&gt; System.out.println(<span class="string">"uss1"</span> + s));</div></pre></td></tr></table></figure>
<h3 id="SerializedSubject"><a href="#SerializedSubject" class="headerlink" title="SerializedSubject"></a>SerializedSubject</h3><p>当我们使用普通的Subject，必须要注意不要在多线程情况下调用onNext方法，<br>而使用SerializedSubject封装原来的 Subject即可！！<br>内部使用了SerializedObserver。查看其doc，如果是多线程环境，即有多个线程发射通知时，它们将被按序列执行：<br>1.允许仅有一个线程，执行一个emit<br>2.如果另一线程，已经emit，将下一个添加到通知队列<br>3.在循环emitting时，不持有任何锁或阻塞任何线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ReplaySubject&lt;String&gt; subject = ReplaySubject.create();</div><div class="line">SerializedSubject&lt;String, String&gt; serializedSubject = <span class="keyword">new</span> SerializedSubject&lt;&gt;(subject);</div><div class="line">serializedSubject.subscribe(s -&gt;</div><div class="line">  	System.out.println(<span class="string">"thread-"</span> + Thread.currentThread().getName() + <span class="string">"--"</span> + s));</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">  	<span class="keyword">int</span> finalIndex = i;</div><div class="line">  	<span class="keyword">new</span> Thread(() -&gt; serializedSubject.onNext(<span class="string">"haha"</span> + finalIndex)).start();</div><div class="line">&#125;</div><div class="line">serializedSubject.onNext(<span class="string">"haha20"</span>);</div><div class="line">serializedSubject.onNext(<span class="string">"haha21"</span>);</div><div class="line">serializedSubject.onNext(<span class="string">"haha22"</span>);</div></pre></td></tr></table></figure>
<h1 id="RxJava操作符"><a href="#RxJava操作符" class="headerlink" title="RxJava操作符"></a>RxJava操作符</h1><p>(most from <a href="http://frodoking.github.io/2015/09/08/reactivex/" target="_blank" rel="external">http://frodoking.github.io/2015/09/08/reactivex/</a>)</p>
<p>大多数操作符：操作一个Observable并且返回一个Observable。</p>
<p>这样允许开发人员以一个链式的方式一个接一个的执行操作符。</p>
<p>在可修改的链式中，每一个操作结果Observable都是来之于上一个操作。</p>
<p>这里有一些类似于构造器Builder模式，该模式描述了一个含有一系方法的特定类通过操作方法来操作具有相同功能的类的每一项。</p>
<p>这个模式也允许你以类似的方式去链式操作方法。在Builder模式中，操作方法出现的顺序在链式中可能不是那么重要， 但是在Observable中的操作符顺序就很重要。</p>
<p>Observable操作符链不会依赖于原来的Observable去操作原始的链，每一个在Observable上的正在操作的operator都是上一个操作立即产生的。</p>
<h2 id="创建Observable-–-创建新的Observable的操作符"><a href="#创建Observable-–-创建新的Observable的操作符" class="headerlink" title="创建Observable – 创建新的Observable的操作符"></a>创建Observable – 创建新的Observable的操作符</h2><ul>
<li><p><strong><em>create</em></strong>——从头创建一个Observable，当观察者订阅Observable时，它作为一个参数传入，并执行call()</p>
</li>
<li><p><strong><em>defer</em></strong>——不立即创建Observable，直到observer触发订阅动作。此方法为每一个observer创建一个新的Observable</p>
</li>
<li><p><strong><em>empty/never/error</em></strong>——为非常精确和有限的行为而创建Observable：空的，不emit数据/不emit数据，且永远不会结束/不emit数据，以onError()结束</p>
</li>
<li><p><strong><em>from</em></strong>——迭代一个序列(集合或数组)，一个一个的发射数据</p>
</li>
<li><p><strong><em>interval</em></strong>——创建一个具有发出一个整数序列间隔为一个特定的时间间隔的Observable</p>
</li>
<li><p><strong><em>just</em></strong>——按顺序emit后面跟的”1到9个”数据</p>
</li>
<li><p><strong><em>range</em></strong>——创建一个Observable,发送一系列连续的整数</p>
</li>
<li><p><strong><em>repeat</em></strong>——创建一个Observable,发送一个特定的项目或项目重复序列</p>
</li>
<li><p><strong><em>timer</em></strong>——创建一个Observable,在一个给定的一段时间延迟后发送一个对象或者项目</p>
<p>​</p>
</li>
</ul>
<h2 id="转换Observables-–-转换成另一个Observable的操作符"><a href="#转换Observables-–-转换成另一个Observable的操作符" class="headerlink" title="转换Observables – 转换成另一个Observable的操作符"></a>转换Observables – 转换成另一个Observable的操作符</h2><ul>
<li><strong>buffer</strong>——定期收集从Observable中发出的数据到集合中，每次发射一组，而不是发送一个</li>
<li><strong>concatMap</strong>——与flatMap非常相似。但它会将展开的元素，一个个有序的连接起来</li>
<li><strong>flatMap</strong>——将一个Observable发送的数据或者项目转换到Observables中，适用于将 T 变换为 Observable<r>，Observable<r>表示一个序列集。发送的次序可能是交错的</r></r></li>
<li><strong>flatMapIterable</strong>——与flatMap类似，只是它会将数据转换成一个Iterable</li>
<li><strong>groupBy</strong>——拆分一个Observable成多个Observable组，并且每个组发送的数据会组成一个不同的发送数据组当然这些发送数据时来自于原始的Observable。这些分组都是通过划分key来实现</li>
<li><strong>map</strong>——转换一个Observable发送的每个数据或者项目映射到一个函数上</li>
<li><strong>scan</strong>——应用一个函数给一个Observable发送出来的每一条数据, 并且是按照顺序发送每个连续值(t1,t2, return R)</li>
<li><strong>switchMap</strong>——与flatMap类似，除了一点: 当源Observable发射一个新的数据项时，</li>
</ul>
<p>如果旧数据项订阅还未完成，就取消旧订阅数据和停止监视那个数据项产生的Observable,开始监视新的数据项</p>
<ul>
<li><strong>window</strong>——类似buffer，但发射的是一个Observable，而不是列表</li>
<li><strong>lift</strong>——针对事件项和事件序列的操作符。对于事件项的类型转换，主要在一个新的Subscriber中完成。</li>
<li><strong>compose</strong>——需要一个Observable.Transformer型的入参。该类型的call()，操作的是一个Observable，并返回另一个Observable。所以compose用于在内部组合一组变换的场景。</li>
</ul>
<h2 id="过滤Observables-–-过滤被Observable发送的数据的操作符"><a href="#过滤Observables-–-过滤被Observable发送的数据的操作符" class="headerlink" title="过滤Observables – 过滤被Observable发送的数据的操作符"></a>过滤Observables – 过滤被Observable发送的数据的操作符</h2><ul>
<li><strong>debounce</strong>——如果Observable在一个特定时间间隔过去后没有发送其他数据或者项目,那么它只发送最后那个</li>
<li><strong>distinct</strong>——该Observable不可以发送重复的数据</li>
<li><strong>distinctUntilChanged</strong>——发送”跟上一个数据不重复”的新值</li>
<li><strong>elementAt</strong>——只发送可观测序列中的某一项。index从0开始</li>
<li><strong>filter</strong>——一个Observable只发送通过来特定测试描述语的匹配项</li>
<li><strong>first</strong>——只发出第一项,或第一项符合条件的项</li>
<li><strong>ignoreElements</strong>——不发送任何数据，但是必须反馈它的中断通知: Observable的onCompleted和onError事件</li>
<li><strong>last</strong>——只发送最后一项</li>
<li><strong>sample</strong>——发出Observables周期时间间隔内最新的项</li>
<li><strong>throttleFirst</strong>——发出Observables周期时间间隔内的第一项</li>
<li><strong>throttleLast</strong>——发出Observables周期时间间隔内的最后一项</li>
<li><strong>skip</strong>——跳过发送前几项</li>
<li><strong>skipLast</strong>——跳过发送后几项</li>
<li><strong>take</strong>——仅仅发送前几项</li>
<li><strong>takeLast</strong>——仅仅发送后几项</li>
</ul>
<h2 id="合并Observables-–-将多个Observables合并成单个的Observable的操作符"><a href="#合并Observables-–-将多个Observables合并成单个的Observable的操作符" class="headerlink" title="合并Observables – 将多个Observables合并成单个的Observable的操作符"></a>合并Observables – 将多个Observables合并成单个的Observable的操作符</h2><ul>
<li><strong><em>combineLatest</em></strong>——当某一项数据由两个Observables发送时，通过一个特殊的函数来合并每一个Observable发送的项，并且最终发送数据是该函数的结果</li>
</ul>
<ul>
<li><strong>join</strong>——合并两个Observables发送的结果数据。其中两个Observable的结果遵循如下规则：</li>
</ul>
<p>每当一个Observable在定义的数据窗口中发送一个数据都是依据另外一个Observable发送的数据。</p>
<ul>
<li><strong><em>merge</em></strong>——通过合并多个Observables发送的结果数据将多个Observables合并成一个</li>
<li><strong><em>mergeDelayError</em></strong>——即使发生了error也不打断merge操作，当所有merge结束后，才发射onError()</li>
<li><strong>startWith</strong>——在Observable源开始发送数据项目之前，先发送一个指定的项目序列</li>
<li><strong><em>zip</em></strong>——它使用这个函数按顺序结合两个或多个Observables发射的数据项，然后它发射这个函数返回的结果。它按照严格的顺序应用这个函数。它只发射与发射数据项最少的那个Observable一样多的数据。</li>
<li><strong>zipWith</strong>——与<strong><em>zip</em></strong>类似，只是一个成员方法，必须由一个Observable来发起。</li>
</ul>
<h2 id="错误处理操作符"><a href="#错误处理操作符" class="headerlink" title="错误处理操作符"></a>错误处理操作符</h2><p>（most from <a href="http://www.jianshu.com/p/5bb3e55a14c4）" target="_blank" rel="external">http://www.jianshu.com/p/5bb3e55a14c4）</a></p>
<ul>
<li><p><strong>retry</strong>——如果一个源Observable发送一个onError通知，需要重新发射，以期望不发生错误。</p>
<p>有三个变体方法：retry()  若有错，一直重新发射，直到无错误； retry(count)  若有错，只重新发射count次，直到无错误；retry(new Func2<integer, throwable,="" boolean="">(){…}) ，三个参数的意思是，正常接收到的值, 发生的异常, 在发生错误时是否要重新发射，重写函数返回值 false 不重新发射。</integer,></p>
</li>
</ul>
<ul>
<li><strong>retryWhen</strong>——retryWhen类似retry。如果发射一个error，会传递给其观察者，并交由retryWhen中的Func1来操作，Func1又由Func2组成。Func2的call函数的返回值决定订阅过程是否重复发生：如果发射的error，订阅会终止，如果发射的是数据项，则会重新订阅</li>
<li><strong>onErrorReturn</strong>——若源Observable发生了错误或异常，替代源Observable调用Observer的onError方法。onErrorReturn中那个Func1实现被调用并接受这个错误或异常作为参数，这个Func1实现的返回值将作为onErrorReturn返回的值</li>
<li><strong>onErrorResumeNext</strong>——源Observable遇到错误，这个onErrorResumeNext会把源Observable用一个新的Observable替掉，然后这个新的Observable如果没遇到什么问题就会释放item给Observer。你可以直接将一个Observable实例传入onErrorResumeNext作为这个新的Observable，也可以传给onErrorResumeNext一个Func1实现，这个Func1实现接受源Observable的错误作为参数，返回新的Observable</li>
<li><strong>onExceptionResumeNext</strong>——与onErrorResumeNext类似。只是onExceptionResumeNext是在发生了Exception时，才触发。如果发生的不是一个Exception，仍会触发Observer的onError方法</li>
</ul>
<h2 id="实用工具操作符"><a href="#实用工具操作符" class="headerlink" title="实用工具操作符"></a>实用工具操作符</h2><ul>
<li><p><strong>delay</strong>——按照一个特定量及时的将Observable发送的结果数据向前推移</p>
</li>
<li><p><strong>do</strong>——注册一个事件去监听Observable生命周期</p>
<p><strong>doOnSubscribe</strong>在<strong>Subscriber#onStart()</strong>时回调</p>
<p><strong>doOnNext</strong>在<strong>Observer#onNext()</strong>时回调</p>
<p><strong>doOnError</strong>在<strong>Observer#onError()</strong>时回调</p>
<p><strong>doOnCompleted</strong>在<strong>Observer#onCompleted()</strong>时回调</p>
<p><strong>doOnEach</strong>在<strong>Observer#onNext()</strong>、<strong>onError()</strong>、<strong>onCompleted()</strong>时都会回调</p>
</li>
<li><p><strong>materialize/Dematerialize</strong>——代表发送出来的项目数据或者通知，或相反过程</p>
</li>
<li><p><strong>observeOn</strong>——指定一个observer将会观察这个Observable的调度</p>
</li>
<li><p><strong>serialize</strong>——强制Observable按次序发射数据并且要求功能是完好的</p>
</li>
<li><p><strong>subscribe</strong>——操作可观测的排放和通知</p>
</li>
<li><p><strong>subscribeOn</strong>——指定一个Observable在被订阅的时候应该使用的调度</p>
</li>
<li><p><strong>timeInterval</strong>——转换一个Observable的发送项目到另一个项目，在这些发送项之间，此项目具有指示这些发送的时间开销功能</p>
</li>
<li><p><strong>timeout</strong>——镜像源Observable,但如果某段时间过后没有任何通知发出将会发出一个错误通知</p>
</li>
<li><p><strong>timestamp</strong>——给一个Observable发送的每一个项目附加一个时间戳</p>
</li>
<li><p><strong>using</strong>——创建一个一次性的资源，这个资源就像Observable一样有相同的寿命</p>
</li>
</ul>
<h2 id="条件和布尔运算操作符-–-评估一个或者多个Observables或者被Observables发送的项目的操作符"><a href="#条件和布尔运算操作符-–-评估一个或者多个Observables或者被Observables发送的项目的操作符" class="headerlink" title="条件和布尔运算操作符 – 评估一个或者多个Observables或者被Observables发送的项目的操作符"></a>条件和布尔运算操作符 – 评估一个或者多个Observables或者被Observables发送的项目的操作符</h2><ul>
<li><strong>all</strong>——确定发出的所有项目满足某些标准</li>
<li><strong><em>amb</em></strong>——给定一组Iterable<observable>来源，只发射第一个Observable的数据</observable></li>
<li><strong>contains</strong>——判断Observable是否包含一个特定的项</li>
<li><strong>defaultIfEmpty</strong>——发送项从Observable源，或者如果Observable源没有任何发送内容，那么将会发送一个默认的项</li>
<li><strong><em>sequenceEqual</em></strong>——确定两个Observables发出相同的序列条目</li>
<li><strong>skipUntil</strong>——丢弃Observable发出的项,直到第二个Observable发出一项</li>
<li><strong>skipWhile</strong>——丢弃Observable发出的项,直到指定的条件变成了false</li>
<li><strong>takeUntil</strong>——在第二个Observable发送一项或者终止之后，丢弃Observable发出的项</li>
<li><strong>takeWhile</strong>——在指定的条件变成了false之后，丢弃Observable发出的项</li>
</ul>
<h2 id="类型转换操作符"><a href="#类型转换操作符" class="headerlink" title="类型转换操作符"></a>类型转换操作符</h2><ul>
<li><strong>to</strong>——将一个Observable转换到另一个对象或数据结构。 toXxx</li>
<li><strong>cast</strong>——传入其它类型Class，进行自动转换</li>
</ul>
<h2 id="可连接到Observable的操作符-–-指定Observables有更多精确控制订阅动态的操作符"><a href="#可连接到Observable的操作符-–-指定Observables有更多精确控制订阅动态的操作符" class="headerlink" title="可连接到Observable的操作符 – 指定Observables有更多精确控制订阅动态的操作符"></a>可连接到Observable的操作符 – 指定Observables有更多精确控制订阅动态的操作符</h2><ul>
<li><strong>connect</strong>——定义一个可连接的Observable发送项目数据给它的订阅者</li>
<li><strong>publish</strong>——把一个普通的Observable转化为一个可连接的Observable（向下转换）</li>
<li><strong>replay</strong>——返回一个Connectable Observable 对象并且可以缓存其发射过的数据，这样即使有订阅者在其发射数据之后进行订阅也能收到其之前发射过的数据。不过使用Replay操作符我们最好还是限定其缓存的大小，否则缓存的数据太多了可会占用很大的一块内存。对缓存的控制可以从空间和时间两个方面来实现，比如它的其它变体实现：replay(int bufferSize)、replay(int bufferSize, long time, TimeUnit unit) …</li>
</ul>
<h2 id="数学操作符"><a href="#数学操作符" class="headerlink" title="数学操作符"></a>数学操作符</h2><p>(For details, please see <a href="https://github.com/ReactiveX/RxJavaMath" target="_blank" rel="external">RxJavaMath</a> and <a href="https://github.com/ReactiveX/RxJava/wiki/Mathematical-and-Aggregate-Operators" target="_blank" rel="external">Mathematical-and-Aggregate-Operators</a>)</p>
<p>主要使用<strong>MathObservable</strong>来操作数据</p>
<ul>
<li><p><strong>average</strong>——计算一个Observable发送所有结果的平均值，并且发射这个值</p>
<p>对应的变体有averageDouble、 averageFloat、 averageInteger、 averageLong</p>
</li>
<li><p><strong>max</strong>——确定,发射最大值项</p>
</li>
<li><p><strong>min</strong>——确定,发射最小值项</p>
</li>
<li><p><strong>sum</strong>——计算Observable发射的所有数据的求和，并且发射这个求和结果</p>
<p>对应的变体有sumDouble、sumFloat、sumInteger、sumLong</p>
</li>
</ul>
<blockquote>
<p>以上方法，都有静态与非静态方法。静态方法要求传入一个Observable<t>；非静态方法可通过<strong><em>from(Observable<t> observable)</t></em></strong>返回一个<strong>MathObservable</strong>，来进行操作。</t></p>
</blockquote>
<h2 id="聚集操作符"><a href="#聚集操作符" class="headerlink" title="聚集操作符"></a>聚集操作符</h2><p>(most from <a href="http://blog.csdn.net/jdsjlzx/article/details/51489793" target="_blank" rel="external">http://blog.csdn.net/jdsjlzx/article/details/51489793</a>)</p>
<ul>
<li><strong><em>concat</em></strong>——顺序连接多个Observables,并且严格按照发射顺序，前一个没有发射完，是不能发射后面的</li>
<li><strong>count/countLong</strong>——计算Observable源发出的项目数据数量，并发出这个值</li>
<li><strong>reduce</strong>——应用一个函数接收Observable发射的数据和函数的计算结果作为下次计算的参数，输出最后的结果。  跟scan操作符很类似，只是scan会输出每次计算的结果，而reduce只会输出最后的结果。</li>
<li><strong>collect</strong>——将原始Observable发射的数据放到一个单一的可变的数据结构中，然后返回一个发射这个数据结构的Observable </li>
<li><strong>toList</strong>——收集原始Observable发射的所有数据到一个列表，然后返回这个列表</li>
<li><strong>toSortedList</strong>——收集原始Observable发射的所有数据到一个有序列表，然后返回这个列表</li>
<li><strong>toMap</strong>——将序列数据转换为一个Map，Map的key是根据一个函数计算的</li>
<li><strong>toMultiMap</strong>——将序列数据转换为一个列表，同时也是一个Map，Map的key是根据一个函数计算的</li>
<li><strong>toBlocking——</strong>转换成一个BlockingObservable。当满足条件的数据发射出来的时候才会返回一个BlockingObservable对象</li>
</ul>
<p>#Schedulers 线程调度</p>
<p>在没有给定调度器（Scheduler）的情况下，Subscription将默认(产生事件与订阅)运行于调用线程上。</p>
<p>线程调度器（Scheduler）是将RxJava从同步观察者模式转到异步观察者模式的一个重要工具。</p>
<p>RxJava提供了5种主要的调度器:</p>
<ul>
<li>Scheduler Schedulers.io()</li>
<li>Scheduler Schedulers.computation()</li>
<li>Scheduler Schedulers.immediate()</li>
<li>Scheduler Schedulers.newThread()</li>
<li>Scheduler Schedulers.trampoline()</li>
</ul>
<p>还有可用于测试的调度器Schedulers.<em>test()</em> 及 可自定义Scheduler—-Schedulers.<em>form()</em></p>
<h2 id="Schedulers-io"><a href="#Schedulers-io" class="headerlink" title="Schedulers.io()"></a>Schedulers.<em>io()</em></h2><p>内部创建一个rx.internal.schedulers.CachedThreadScheduler。底层实现是一个java中的ScheduledThreadPoolExecutor (extends ThreadPoolExecutorimplements ScheduledExecutorService)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123;</div><div class="line">  <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE,</div><div class="line">        DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</div><div class="line">        <span class="keyword">new</span> DelayedWorkQueue(), threadFactory);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>corePoolSize=1, DEFAULT_KEEPALIVE_MILLIS=10L, DelayedWorkQueue是一个二叉树结构实现的BlockingQueue</p>
<p>整体还是一个无界(即容量特别大)的队列实现</p>
<p>例如，存储Bitmap到本地时，可以直接在Schedulers的io线程中执行任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">storeBitmap</span><span class="params">(Context context, Bitmap bitmap, String filename)</span> </span>&#123;</div><div class="line">    Schedulers.io().createWorker().schedule(() -&gt; &#123;</div><div class="line">        blockingStoreBitmap(context, bitmap, filename);</div><div class="line">	&#125;); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Schedulers-computation"><a href="#Schedulers-computation" class="headerlink" title="Schedulers.computation()"></a>Schedulers.<em>computation()</em></h2><p>内部是由 rx.internal.schedulers.EventLoopsScheduler 实现的。</p>
<p>这个是计算工作默认的调度器，它与I/O操作无关。它也是许多RxJava方法的默认<br>调度器: <strong>buffer()</strong>、<strong>debounce()</strong>、<strong>delay()</strong>、<strong><em>interval()</em></strong>、<strong>sample()</strong>、<strong>skip()</strong>        </p>
<h2 id="Schedulers-immediate"><a href="#Schedulers-immediate" class="headerlink" title="Schedulers.immediate()"></a>Schedulers.<em>immediate()</em></h2><p>内部创建一个rx.internal.schedulers.ImmediateScheduler。 这个调度器允许你立即在当前线程执行指定的工作。</p>
<p>它是  <strong>timeout()</strong>、<strong>timeInterval()</strong> 及 <strong>timestamp()</strong> 方法默认的调度器</p>
<h2 id="Schedulers-newThread"><a href="#Schedulers-newThread" class="headerlink" title="Schedulers.newThread()"></a>Schedulers.<em>newThread()</em></h2><p>内部创建一个rx.internal.schedulers.NewThreadScheduler。一底层跟<strong><em>Schedulers.io()</em></strong>一样是由java的ScheduledThreadPoolExecutor实现。</p>
<p>它为指定任务启动一个新的线程</p>
<h2 id="Schedulers-trampoline"><a href="#Schedulers-trampoline" class="headerlink" title="Schedulers.trampoline()"></a>Schedulers.<em>trampoline()</em></h2><p>内部创建一个rx.internal.schedulers.TrampolineScheduler。运行在当前线程。当有新任务时，并不会立即执行，而是将它加入队列PriorityBlockingQueue中，直到运行任务执行完成后，才从队列中按序取出一个继续执行。</p>
<p>它是<strong><em>repeat()</em></strong>和<strong>retry()</strong>默认的调度器</p>
<h2 id="用于测试的调度器Schedulers-test"><a href="#用于测试的调度器Schedulers-test" class="headerlink" title="用于测试的调度器Schedulers.test()"></a>用于测试的调度器Schedulers.<em>test()</em></h2><p>(some from <a href="http://blog.csdn.net/siguoyi/article/details/51849964" target="_blank" rel="external">http://blog.csdn.net/siguoyi/article/details/51849964</a>)</p>
<p>创建一个rx.schedulers.TestScheduler。这是一个公开的可访问的类。也可以直接使用无参构造方法，new出一个实例。</p>
<p>主要提供如下三个方法，来对调度器的时钟表现进行手动微调，这对依赖精确时间安排的任务的测试很有用处。</p>
<ul>
<li><strong>advanceTimeBy(time,unit)</strong> 将调度器时时钟，前进一个指定时间。这是相对操作</li>
<li><strong>advanceTimeTo(time,unit)</strong> 将调度器时钟拨动到一个指定的时间。 这个是绝对操作</li>
<li><strong>triggerActions( )</strong> 开始执行任何计划中的但是未启动的任务，如果它们的计划时间等于或者早于调度器时钟的当前时间</li>
</ul>
<blockquote>
<p>假定当前时间为0， 先advanceTimeBy(2, TimeUnit.SECONDS)再advanceTimeTo(2, TimeUnit.SECONDS)，那么现在时间还是2。若反过来调用，那么现在时间就是4b了</p>
</blockquote>
<h2 id="自定义Scheduler—-Schedulers-form"><a href="#自定义Scheduler—-Schedulers-form" class="headerlink" title="自定义Scheduler—-Schedulers.form()"></a>自定义Scheduler—-Schedulers.<em>form()</em></h2><p>使用Schedulers.<em>form(java.util.concurrent.Executor executor)</em> ，来自定义Scheduler</p>
<h2 id="subscribeOn-和observeOn"><a href="#subscribeOn-和observeOn" class="headerlink" title="subscribeOn()和observeOn()"></a>subscribeOn()和observeOn()</h2><p><strong>subscribeOn()</strong>和<strong>observeOn()</strong> 是用来指定事件生产与订阅在哪个线程执行的。</p>
<ul>
<li>默认没有定义observeOn、subscribeOn，即运行于当前线程</li>
<li>subscribeOn 指定 订阅事件发生(OnSubscribe)的线程。若仅出现它，不出现observeOn, 还会影响其它所有事件</li>
<li>observeOn 指定 在其之后的所有事件发生的线程，即使后面出现了 subscribeOn</li>
<li>若两者同时出现，subscribeOn 影响 observeOn 出现前的所有事件 及 OnSubscribe 事件</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Action1 action = (Action1&lt;String&gt;) s -&gt; </div><div class="line">  	System.out.println(<span class="string">"test-Observer: "</span> + Thread.currentThread().getName() + <span class="string">", "</span> + s);</div><div class="line"></div><div class="line">Observable.Transformer&lt;Integer, String&gt; transformer = integerObservable -&gt;</div><div class="line">                integerObservable.map((Func1&lt;Integer, String&gt;) integer -&gt;</div><div class="line">                        <span class="string">"test-tran.call: "</span> + Thread.currentThread().getName() + <span class="string">", "</span> + integer);</div><div class="line"></div><div class="line">Observable.create((Observable.OnSubscribe&lt;Integer&gt;) subscriber -&gt; &#123;</div><div class="line">  	System.out.println( <span class="string">"test-OnSubscribe.call: "</span> + Thread.currentThread().getName());</div><div class="line">  	subscriber.onNext(<span class="number">9</span>);      &#125;).subscribeOn(io()).observeOn(AndroidSchedulers.mainThread()).compose(transformer).subscribe(action);</div></pre></td></tr></table></figure>
<h1 id="背压-Backpressure"><a href="#背压-Backpressure" class="headerlink" title="背压(Backpressure)"></a>背压(Backpressure)</h1><p>(most from <a href="https://zhuanlan.zhihu.com/p/24473022?refer=dreawer" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/24473022?refer=dreawer</a>)</p>
<p>背压是指在异步场景中，被观察者发送事件速度远快于观察者的处理速度的情况下，一种告诉上游的被观察者降低发送速度的策略。简而言之，背压是流速控制的一种策略。</p>
<p>若被观察者发送事件的速度太快，而观察者处理太慢，而且还没有做相应背压措施，可能抛出MissingBackpressureException</p>
<h2 id="压力异常示例"><a href="#压力异常示例" class="headerlink" title="压力异常示例"></a>压力异常示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Observable.interval(<span class="number">1</span>, TimeUnit.MILLISECONDS)</div><div class="line">                .observeOn(Schedulers.newThread())</div><div class="line">                .subscribe(aLong -&gt; &#123;</div><div class="line">                    Log.w(<span class="string">"TAG"</span>,<span class="string">"----&gt;"</span>+aLong);</div><div class="line">                &#125;);</div></pre></td></tr></table></figure>
<p>上面的interval操作符，在1毫秒产生一个事件，速率过快，订阅者”消费”事件来不及处理，就会出现异常。</p>
<h2 id="自带背压处理的操作符"><a href="#自带背压处理的操作符" class="headerlink" title="自带背压处理的操作符"></a>自带背压处理的操作符</h2><p>用自带背压处理的操作符来处理压力。</p>
<h3 id="过滤策略"><a href="#过滤策略" class="headerlink" title="过滤策略"></a>过滤策略</h3><p>使用之前讲的”过滤操作符”，就可以有效缓解压力。</p>
<p>比如，使用<strong>throttleFirst</strong>来获取一段周期时间内的首个事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable.interval(<span class="number">1</span>, TimeUnit.MILLISECONDS)</div><div class="line">                .observeOn(Schedulers.newThread())</div><div class="line">  			   .throttleFirst(<span class="number">200</span>, TimeUnit.MILLISECONDS)</div><div class="line">                .subscribe(aLong -&gt; &#123;</div><div class="line">                    Log.w(<span class="string">"TAG"</span>,<span class="string">"----&gt;"</span>+aLong);</div><div class="line">                &#125;);</div></pre></td></tr></table></figure>
<h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><p>缓存就是虽然被观察者发送事件速度很快，观察者处理不过来，但是可以选择先缓存一部分，然后慢慢读。</p>
<p>主要用到的是<strong>buffer</strong>操作符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Observable.interval(<span class="number">1</span>, TimeUnit.MILLISECONDS)</div><div class="line">                .observeOn(Schedulers.newThread())</div><div class="line">  			   <span class="comment">//这个操作符简单理解就是把100毫秒内的事件打包成list发送</span></div><div class="line">                .buffer(<span class="number">100</span>,TimeUnit.MILLISECONDS)</div><div class="line">                .subscribe(aLong -&gt; &#123;</div><div class="line">                    Log.w(<span class="string">"TAG"</span>,<span class="string">"----&gt;"</span>+aLong);</div><div class="line">                &#125;);</div></pre></td></tr></table></figure>
<h3 id="按需拉取策略"><a href="#按需拉取策略" class="headerlink" title="按需拉取策略"></a>按需拉取策略</h3><p>就是需要”消费”多少个事件，自己告诉被观察者，最终实现了上游被观察者发送事件的速度的控制</p>
<p>主要使用<strong>request(long n)</strong>。这是一个protected方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">Observable.range(<span class="number">100</span>, <span class="number">10000</span>)<span class="comment">//从100开始，发送10000个数，即最后发送10100</span></div><div class="line">  .observeOn(Schedulers.newThread())</div><div class="line">  .subscribe(<span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</div><div class="line"></div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onStart();</div><div class="line">        <span class="comment">//在onStart中通知被观察者先发送一个事件</span></div><div class="line">        request(<span class="number">1</span>);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line"></div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</div><div class="line">        Log.w(<span class="string">"TAG"</span>,<span class="string">"----&gt;"</span>+ integer);</div><div class="line">        request(<span class="number">1</span>); <span class="comment">//处理完毕之后，再通知被观察者发送下一个事件</span></div><div class="line">      &#125;</div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
<p>上面的代码中，其实可以去掉request相关代码，因 range –&gt; observeOn，这一段过程本身就是响应式拉取数据。</p>
<p>observeOn这个操作符内部有一个缓冲区RxRingBuffer，其在Android环境下长度是16，它会告诉range最多发送16个事件，充满缓冲区即可</p>
<h2 id="让不支持背压的Observable“支持”背压"><a href="#让不支持背压的Observable“支持”背压" class="headerlink" title="让不支持背压的Observable“支持”背压"></a>让不支持背压的Observable“支持”背压</h2><p>对于不支持背压的Observable除了使用上述两类生硬的操作符之外，还有更好的选择：onBackpressureBuffer、onBackpressureDrop。</p>
<p>onBackpressurebuffer：把Observable发送出来的事件做缓存，当request方法被调用的时候，<br>给下层流发送一个item(如果给这个缓存区设置了大小，那么超过了这个大小就会抛出异常)。</p>
<p>onBackpressureDrop：将Observable发送的事件抛弃掉，直到Subscriber再次调用request（n）方法的时候，<br>就发送给它这之后的n个事件。</p>
<p>使用了这两种操作符，可以让原本不支持背压的Observable“支持”背压了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable.interval(<span class="number">1</span>, TimeUnit.MILLISECONDS)</div><div class="line">  	.onBackpressureBuffer()</div><div class="line">  	.observeOn(Schedulers.newThread())</div><div class="line">  	.subscribe(aLong -&gt; &#123;</div><div class="line">		Log.w(<span class="string">"TAG--"</span>,<span class="string">"----&gt;"</span>+aLong);</div><div class="line">	&#125;);</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://aa86799.github.io/2017/05/02/rxjava 1.x/" data-id="cj7sppyi10001yp9wwn8so5c7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/05/06/ThreadPoolExecutor分析/">ThreadPoolExecutor 线程池调度器</a>
          </li>
        
          <li>
            <a href="/2017/05/02/rxjava 1.x/">RxJava1.x 你需要了解的</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 stone<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>