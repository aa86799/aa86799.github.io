<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[c语言中的枚举]]></title>
    <url>%2F2017%2F09%2F29%2Fc%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[枚举 用于声明一组常数。当一个变量有几个固定的可能取值时，可以将这个变量定义为枚举类型 类型定义 enum Season {Spring, Summer, Autumn, Winter}; 定义变量 与结构体一样，有三种方式： 12enum Season &#123;Spring, Summer, Autumn, Winter&#125;;enum Season s; 1enum Season &#123;Spring, Summer, Autumn, Winter&#125; s; 1enum &#123;Spring, Summer, Autumn, Winter&#125; s; 枚举常量的意义 C语言编译器会将枚举元素(Spring、Summer等)作为整型常量处理，称为枚举常量。 枚举常量默认值 枚举元素的值取决于定义时各枚举元素排列的先后顺序。默认情况下，第一个枚举元素的值为0，第二个为1，依次顺序加1。 enum Season {Spring, Summer, Autumn, Winter}; 也就是说Spring的值为0，Summer的值为1，Autumn的值为2，Winter的值为3 改变枚举常量的值 enum Season {Spring, Summer = 3, Autumn, Winter}; 没有指定值的枚举元素，其值为前一元素加1。也就说Spring的值为0，Summer的值为3，Autumn的值为4，Winter的值为5 使用方式 123456enum Season &#123; Spring, Summer =18, Autumn, Winter&#125; season;season = 9; //可以对变量赋值成其它整型常量值season = Spring; //赋值成 枚举常量值 遍历 普通方式 123for (int i = Spring; i&lt;= Winter; ++i) &#123; printf("枚举元素：%d \n", i);&#125; 如果改变了中间的枚举常量值，那么在 遍历的时候，也无法 遍历出正确的元素值。 所以不要随意改变枚举常量的值，当然仅在声明时改变首元素的值，对遍历还是无影响的。 指针方式(有问题) 1234enum Season *s = &amp;season;for (int i = 0; i &lt;=4; i++) &#123; printf("枚举sea2元素：%d \n", *(s+i)); //跟数组不一样，不是连贯存储的，所以用指针遍历无效&#125; ​]]></content>
      <categories>
        <category>C 语言</category>
      </categories>
      <tags>
        <tag>C-Key:union</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言中的共用体]]></title>
    <url>%2F2017%2F09%2F29%2Fc%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%85%B1%E7%94%A8%E4%BD%93%2F</url>
    <content type="text"><![CDATA[共用体(union) 进行某些算法的C语言编程的时候，需要使几种不同类型的变量存放到同一段内存单元中。也就是使用覆盖技术，几个变量互相覆盖。这种几个不同的变量共同占用一段内存的结构，在C语言中，被称作“共用体”类型结构，简称共用体。 也叫 联合体。 共用体变量的地址和它的各成员的地址都是同一地址。其所占内存，与占用内存最大的成员变量一致。 定义 语法格式： 1234union 共用体名&#123; 成员列表&#125; 变量列表; 使用方式 与结构体的使用方式基本是一样的。也可以出现在结构体类型中；反之，结构体类型也可以出现在共用体类型中。 使用注意点：1234567891011union Combo &#123; int a; float b; char c;&#125; cob;cob.b = 70.8f;cob.a = cob.b + 3;printf("---&gt; %d\n", cob.a);printf("占用字节 %lu\n", sizeof(cob));printf("---&gt;字符 %c\n", cob.c); 输出： 123---&gt; 73占用字节 4---&gt;字符 I 上面的示例，可以看出：cob.c对应的整数值就是cob.a的值，即73。符合，共用体的内存覆盖技术。 但是要注意，在共用体中，整数和浮点数相互间不会自动转换。 将上面的使用代码修改一下： 1234567 cob.a = 70; cob.b = cob.a + 3;// cob.a = cob.b; printf("---&gt; %d\n", cob.a); printf("占用字节 %lu\n", sizeof(cob)); printf("---&gt;字符 %c\n", cob.c); printf("---&gt; %f\n", cob.b); 会发现，cob.a和cob.c的输出结果，都跟预计的不一样，是错误的值。因为，这时存储的最新的值是一个float型，所以也就不能正确输出cob.a和cob.c。 若，将上面的注释行打开，发现cob.a和cob.c 都输出正确了，但cob.b又不对了，因整数和浮点数相互间不会自动转换。]]></content>
      <categories>
        <category>C 语言</category>
      </categories>
      <tags>
        <tag>C-Key:union</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言中的结构体]]></title>
    <url>%2F2017%2F09%2F28%2Fc%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%2F</url>
    <content type="text"><![CDATA[结构体(struct) 将一组不同类型的元素定义在一起，且以struct声明，就是结构体。 12345struct Person &#123; char name[20]; //char *name; int age; float weight;&#125;; 定义 不允许对结构体本身递归定义 如下定义是错误的， 1234truct Student &#123; int age; struct Student stu; //error&#125;; ​ 结构体内可以包含别的结构体 结构体变量占用的内存空间是其成员所占内存之和，而且各成员在内存中按定义的顺序依次排列 三种结构体变量定义形式 先定义结构体类型，再定义变量 1234567struct Person&#123; char name[20]; int age; float weight;&#125;;struct Person person; 结构体类型与变量同时定义 1234struct Student &#123; char *name; int age;&#125; stu; 省略类型，结构体变量名为stu 1234struct &#123; char *name; int age;&#125; stu; 在定义变量的位置，是可以定义多个变量的： 12345&gt; struct &#123;&gt; char *name;&gt; int age;&gt; &#125; stu1, stu2, stu3;&gt; 初始化 先定义，后初始化 12345678struct Person &#123; char name[20]; int age; float weight;&#125;;int main() &#123; struct Person person = &#123;"a", 28, 55.5f&#125;;&#125; ​ 定义时，并初始化 123456struct Person&#123; char name[20]; int age; float weight;&#125; person = &#123;"a", 28, 55.5f&#125;; 初始化的时候，可以按顺序赋值一些变量，而不全部赋值，与数组类似 1234567&gt; struct Person&gt; &#123;&gt; char name[20];&gt; int age;&gt; float weight;&gt; &#125; person = &#123;"a", 28&#125;;&gt; 不能在初始时，先声明变量，再初始化 如下，是错误的 12struct Person person; person = &#123;"a", 28, 55.5f&#125;; //error ​ 使用 以 “变量名.属性”来使用 1person.age = 18; 结构体中， 若以 char name[20]; 字符数组形式声明： 不能直接用 person.name = &quot;name&quot;；来赋值。 要以 strcpy(person.name, &quot;name&quot;); 这样的形式来赋值。 若声明成 char *name; 则不会有这样的问题 结构体数组 跟结构体变量一样，结构体数组也有3种定义方式 初始化与数组类似 struct Person person = { {}, {}, {} } 123456789101112131415//第一种struct Student1 &#123; int grade; &#125;; struct Student1 stu1[3];//先定义结构体类型，再定义变量 //第二种struct Student2 &#123;//直接在变量后声明数组 int grade; &#125;stu2[3]; //第三种struct &#123;//省略结构体名字，并声明为数组 int grade; &#125;stu3[3]; 结构体作为函数参数 值传递: 将结构体变量作为函数参数进行传递时，其实传递的是全部成员的值，也就是将实参中成员的值一一赋值给对应的形参成员。因此，形参的改变不会影响到实参。 指向结构体的指针 结构体指针变量的定义形式：struct 结构体名称 *指针变量名，如: 12struct Person p =&#123;..&#125;; struct *xp = &amp;p; 有了指向结构体的指针，那么就有3种访问结构体成员的方式： 1234printf("%s\n", p.name);//下面两种是用 指针变量来访问结构体成员printf("%s\n", (*xp).name);//因为 .优先级高，所以要括起来(*xp)printf("%s\n", xp-&gt;name);]]></content>
      <categories>
        <category>C 语言</category>
      </categories>
      <tags>
        <tag>C指针</tag>
        <tag>C-Key:struct</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言中的变量与函数]]></title>
    <url>%2F2017%2F09%2F26%2Fc%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E4%B8%8E%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[变量 局部变量在函数内部定义的变量，称为局部变量。 函数的形参也是局部变量 全局变量所有在函数外部定义的变量，称为全局变量 全局变量的作用范围是从定义变量的位置开始到源程序结束，即全局变量可以被在其定义位置之后的其它函数所共享。 变量的存储类型C语言根据变量的存储类型(变量存储的位置：1. 运行时堆栈 2.普通内存 3.寄存器)的不同，可以把变量分为：自动变量、静态变量、寄存器变量 哪些是自动变量：被关键字auto修饰的局部变量都是自动变量，但是极少使用这个关键字， 基本上是废的，因为所有的局部变量在默认情况下都是自动变量。存于堆栈 哪些是静态变量： 存于内存，程序结束才销毁 所有的全局变量都是静态变量 被关键字static修饰的局部变量也是静态变量 哪些变量是寄存器变量： 被关键字register修饰的局部(自动)变量都是寄存器变量 只有局部变量才可以是寄存器变量，全局变量和静态局部变量不行 寄存器变量只限于int、char和指针类型变量使用 static与全局变量、局部变量static修饰的变量，其生命周期是存活于整个程序的运行期间的。 静态局部变量 因其生命周期原因，所以值的变化，会影响之后的操作。 123456789void test_static_params() &#123; static int pp = 8; pp++; printf("%d\n", pp); &#125; for (int i=0; i&lt;5; i++) &#123; test_static_params();&#125; 上例，会输出；9 10 11 12 13 静态全局变量 定义在函数外，如：static int MAX = 10; 这样的变量，即为静态的全局变量，通常定义在”头文件”中。 static 修饰时，不能再有 extern 同时修饰。 extern与全局变量、局部变量 默认情况下 一个函数不可以访问在它后面定义的全局变量，若要使它可以访问，则需要在函数外声明并加上extern，如： 12345extern int xx;void test1() &#123; printf("x===%d\n", xx);&#125;int xx = 99; 声明在函数外的变量，默认就是全局的，extern可以省略。 多次声明同一个全局变量 这种情况下，不会报错，只表示一个变量。 即使在多个源文件中声明的同名的全局变量，也都代表着同一个变量。 前面说过，extern可以省略，都是表示全局变量。 但，如下情况是会报错的： 123456789//file: test.hextern int MAX;//file: main.c#include "test.h"extern int MAX;main &#123; MAX = 10;&#125; 如下这样使用，也是有问题的： 123456789//file: test.hint MAX;//file: main.c#include "test.h"extern int MAX;main &#123; MAX = 10;&#125; 还有，两个文件中都定义成 int MAX， 也不行。 那么除去上面三种情况，只有一种是正确的：test.h 定义成 extern int MAX； 在main.c中 int MAX extern 修饰的全局变量，不建议直接声明时初始化 使用extern 声明后，需要再 『定义』一次，即不使用extern 进行定义。这时会分配内存空间，且可以进行初始化 多个文件中都存在同一个全局变量时：在要使用的地方，需要使用 『定义』式，以分配空间。 在局部变量前 加extern 12345int y = 10; //这样声明并初始化是可以的， 但加上extern后，xcode报了警告，不影响运行void test() &#123; // int y = 11; //这是局部变量 extern int y = 12; //这是全局变量&#125; 同名的局部变量和全局变量，是不能在同一个函数内，同时出现的。 函数 内部函数static 修饰的函数为内部函数，该函数就只能在其定义所在的文件中使用。 1static void inner(void);//无参时，写上一个void， xcode编译器推荐，一般仅定义在头文件上 定义在前面的函数，可以访问定义在后面的所有函数 外部函数extern 修饰的函数为外部函数。一般省略该关键字，即默认就是外部函数 1extern void outer(void); 通常在头文件中，定义好外部函数；在源文件中进行实现。 要引用其它外部函数时，只需要引入其所在的头文件： #include &quot;inner.h&quot; 若，当前源文件中的函数 与 引用的外部函数 同名，且参数个数与类型一致，会报错。]]></content>
      <categories>
        <category>C 语言</category>
      </categories>
      <tags>
        <tag>C Functions</tag>
        <tag>C-Key:register</tag>
        <tag>C-Key:static</tag>
        <tag>C-Key:extern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言 字符串、指针、预处理指令]]></title>
    <url>%2F2017%2F09%2F25%2FC%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8C%87%E9%92%88%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[字符串c中没有类似java的字符串类型 用一个一维的char数组来存字符串, 尾部必须有一个空字符(‘\0’)来作为结束： 1234567char a[] = "stone"; //自动在尾部追加空字符char b[2]= &#123;'a', '\0'&#125;; //空字符也占有一个元素位置char c[2]=&#123;'a', 'b'&#125;; //这并不是一个字符串 以printf("%s", c); 来输出 结果与预期不符char names[2][10] = &#123; &#123;'J','a','y','\0'&#125;, &#123;'J','i','m','\0'&#125; &#125;; //这样的二维数组，其中每个一维数组，都浪费了6个空间 指针指针用来指向一块内存地址。如：int a = 10; int p = &a; int c = p; 字符串指针：char p = “admin”， char q = p; char q = p; 与 char q = &amp;p[0]; 效果一样的(数组的首元素地址就是该数组的地址) 。 而 char *q=&amp;p[1]; 打印q, 输出：”dmin” 遍历： 123for (; *p != '\0'; p++) &#123; printf("=%c ", *p);&#125; ​ 当使用指针遍历后，这时地址位已经移到结束符的位置了。所以想重置时，需要 p -= 5; 交换字符： 12345void swap(char *p,char *q) &#123; char temp = *p; *p = *q; *q = temp;&#125; 交换字符串： 12345void swapstr(char **p, char **q) &#123; char *temp = *p; *p = *q; *q = temp;&#125; 指针和数组的互换形参数组，实参指针123456789101112131415void change(int b[]) &#123; b[0] = 10;&#125;int main() &#123; // 定义一个int类型的数组 int a[4] = &#123;1, 2, 3, 4&#125;; int *p = a; // 将数组名a传入change函数中 //change(a); change(p); //直接传入指针变量 // 查看a[0] printf("a[0]=%d", a[0]); return 0;&#125; 形参指针，实参数组12345678910111213141516171819void change(int *b) &#123; b[0] = 10; // 或者*b = 10; b[1] = 11; // 或 *(b+1) = 11;&#125;int main(int argc, char *argv[]) &#123; // 定义一个int类型的数组 int a[4] = &#123;1, 2, 3, 4&#125;; // 将数组名a传入change函数中 change(a); //遍历 int len = sizeof(a) / sizeof(int); for (int i=0; i&lt;len; i++) &#123; printf("%d\n", a[i]); &#125; return 0;&#125; 错误使用举例首先要牢记一点，指针表示一个内存地址。 12char *a = "stone";*a = "aaa"; //error a 表示 a指向的值，而字符串就是一组字符序列，所以实际 a指代的是字符数组a 的首位的值 简单的说： 不能将一个常量值，赋给另一个常量 正确的写法：a = &quot;aaa&quot;; //将常量赋给变量 12char b[] = "stone";b = "aaaa"; //error 这里 b 还是指代的字符数组的首地址。 参照上面的遍历 来理解。 正确代码，需要用一个临时的指针变量： 12char *p = b;p = "aaaa"; //fine 计算数组的长度。 12int a[4] = &#123;1, 2, 3, 4&#125;;int len = sizeof(a) / sizeof(int); 如上，能得出一个正确的值。 但，若是将该数组传递到一个函数里，再进行计算可能就有问题了 123void calc_len(int *p) &#123; int len = sizeof(p) / sizeof(int); //p表示地址 len=2&#125; 解决方法：在外部计算好数组长度，再传递给函数。 ​ 返回指针的函数返回指针的函数的一般形式为：类型名 *函数名(参数列表) 1char * getstr() &#123;...&#125; 指向函数的指针 定义的一般形式：函数的返回值类型(*指针变量名)(形参1, 形参2,...) = 函数名; 123456789int sum(int a, int b) &#123; return a + b;&#125;int main() &#123; int (*q) (int a, int b) = sum;// (int a, int b) 可以写成(int a, int)或(int,int)或() int result = (*q)(2,5);//调用函数 printf("\n%d", result); return 0;&#125; 将函数指针作为形参123456789void get(int (*p)(), int a, int b) &#123;//第一个参数即为函数形参//void get(int (*p)(int, int), int a, int b) &#123; //与上一句 等价 int result = (*p)(a, b); printf("sum = %d\n", result);&#125;int main() &#123; int (*q)() = sum; get(*q, 10, 20);&#125; 预处理指令C语言在对源程序进行编译之前，会先对一些特殊的预处理指令作解释(比如#include文件包含指令)，产生一个新的源程序(这个过程称为编译预处理),之后再进行通常的编译 预处理指令可以出现在程序的任何位置，它的作用范围是从它出现的位置到文件尾。 宏#define 用来定义一个宏 不带参数的宏定义格式：define 宏名 字符串, 如define ABC 10 右边的字符串也可以省略，比如#define ABC 它的作用是在编译预处理时，将源程序中所有”宏名”替换成右边的”字符串”，常用来定义常量 宏名的有效范围是从定义位置到文件结束。如果需要终止宏定义的作用域，可以用#undef ABC命令 省略右边字符串的宏， 主要用于 『条件编译』指令中 带参数的宏定义格式：define 宏名(参数列表) 字符串 注意：宏名和参数列表间不能有空格 在编译预处理时，将源程序中所有宏名替换成字符串，并且将 字符串中的参数用 宏名右边参数列表中的参数替换 123456789#include &lt;stdio.h&gt;#define average(a, b) (a+b)/2int main ()&#123; int a = average(10, 4); // 替换成 (10+4)/2 printf("平均值：%d", a); return 0;&#125; 引用已经定义的宏名123#define R 3.0#define PI 3.14#define L 2*PI*R 条件编译程序的其中一部分代码只有在满足一定条件时才进行编译， 否则不参与编译(只有参与编译的代码最终才能被执行)，这就是条件编译 语法格式： 12345678910111213#if 条件1 ...code1...#elif 条件2 ...code2...#else ...code3...#endif //条件编译结束标记 必须有 一般用来判断宏或常量， 不能判断 非预编译 的 运行时 变量。 例：123456789#define MAX 5#if MAX == 0 printf("MAX是0");#elif MAX &gt; 0 printf("MAX大于0");#else printf("MAX小于0");#endif 判断是否定义过宏：1234#if defined(MAX)// &lt;==&gt; #ifdef MAX ...code...#elif !defined(MAX)// &lt;==&gt; #ifndef MAX#endif 文件包含指令第1种形式#include&lt;文件名&gt;直接到C语言库函数头文件所在的目录中寻找文件 12#include &lt;stdio.h&gt;#include &lt;string.h&gt; 第2种形式#include&quot;文件名&quot;这种形式下，系统会先在源程序当前目录下寻找，若找不到，再到操作系统的path路径中查找，最后才到C语言库函数头文件所在目录中查找 注意：#include指令允许嵌套包含，比如a.h包含b.h，b.h包含c.h， 但是不允许递归包含，比如 a.h 包含 b.h，b.h包含 a.h 使用#include指令可能导致多次包含同一个头文件，降低编译效率 解决方法：在包含的文件里，加上条件编译指令，防止函数被重复定义, 如： 123456#ifndef c_program_cc_h#define c_program_cc_hmethod 1();method 2();………….#endif C中没有类似java的package的概念，它只有文件系统。 如果要引入当前目录下的文件夹util中的calcUtil.h : #include &quot;calcUtil.h&quot;]]></content>
      <categories>
        <category>C 语言</category>
      </categories>
      <tags>
        <tag>C字符串</tag>
        <tag>C指针</tag>
        <tag>C-Key:include</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言库函数]]></title>
    <url>%2F2017%2F09%2F25%2Fc%E8%AF%AD%E8%A8%80%E5%BA%93%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[stdio.h include &lt;stdio.h&gt;; printf(“可以在这写要输出的字符串格式，以 %x 的形式，格式化后面的参数”, params…); sizeof(一个变量或者一个常量、一种数据类型); 可以用来计算参数所占的字节数 putchar(90); 输出一个字符：参数可以是一个字符，或一个字符对应的int值。 注： char c = 90; 是有效的 getchar(); 读取输入一个字符。可以读入空格、TAB、回车(读回车时连击两次)，直到遇到回车为止。 scanf(..); 可以接收多个输入 ——接收一个字符串：char a[10]; scanf(“%s”, a); ——接收多个数据：char a[10]; int x; scanf(“%d, %s”, &amp;x, a); ————多个数据间的分隔符可以是任意符号， 这里是 逗号 ————后面的参数为，指定接收的变量的 内存地址 string.h include &lt;string.h&gt; strlen(char*); 返回字符串长度， 不包括 ‘\0’ 结束符 strcpy(char dest, char src); 将src复制到dest中，原dest覆盖。 要注意size: dest是否能容纳src strcat(char dest, char src); 将src追加到dest的尾部。 要注意size: dest是否能容纳 dest+src strcmp(char s1, char s2); 个字符串从左至右逐个字符比较（按照字符的ASCII码值的大小）， ——直到字符不相同或者遇见’\0’为止。如果全部字符都相同，则返回值为0。 ——如果不相同，则返回两个字符串中第一个不相同的字符ASCII码值的差。 ——即字符串1大于字符串2时函数返回值为正，否则为负。 puts(char*); 输出一个字段串。输出时直到遇见’\0’为止。 gets(char); 读取一个字符串。 char buffer[20];char r = gets(buffer);]]></content>
      <categories>
        <category>C 语言</category>
      </categories>
      <tags>
        <tag>C Functions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查找安卓api24以上的ApiDemos]]></title>
    <url>%2F2017%2F09%2F20%2F%E5%AE%89%E5%8D%93api24%E4%BB%A5%E4%B8%8A%E7%9A%84ApiDemos%2F</url>
    <content type="text"><![CDATA[源码下载地址：https://android.googlesource.com/platform/development.git 该项目以git管理，不同的tag标签上，就有不同的版本号。项目下samples目录就是代码示例，samples目录内，就有ApiDemos工程.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ApiDemos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadPoolExecutor 线程池调度器]]></title>
    <url>%2F2017%2F05%2F26%2FThreadPoolExecutor%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[可设置的主要参数 corePoolSize 核心线程数，核心线程会一直存活，即使没有任务需要处理。当线程数小于核心线程数时，即使现有的线程空闲，线程池也会优先创建新线程来处理任务，而不是直接交给现有的线程处理。 核心线程在allowCoreThreadTimeout被设置为true时会超时退出，默认情况下不会退出。 maxPoolSize 当线程数大于或等于核心线程，且任务队列已满时，线程池会创建新的线程，直到线程数量达到maxPoolSize。如果线程数已等于maxPoolSize，且任务队列已满，则已超出线程池的处理能力，线程池默认会拒绝处理任务而抛出异常。可以自定义处理多余任务的RejectedExecutionHandler 该参数在某些情况下是无效的。 keepAliveTime 当已经执行过的线程空闲后，空闲时间小于keepAliveTime，又来了新的任务时，会直接启动该线程。 当线程空闲时间达到keepAliveTime，该线程会退出，直到线程数量等于corePoolSize。 如果allowCoreThreadTimeout设置为true，则所有线程均会退出直到线程数量为0。 allowCoreThreadTimeout 是否允许核心线程空闲退出，默认值为false。 queueCapacity 任务队列容量，由它设定一个有界的队列。从maxPoolSize的描述上可以看出，任务队列的容量会影响到线程的变化，因此任务队列的长度也需要恰当的设置。 RejectedExecutionHandler 123public interface RejectedExecutionHandler &#123; void rejectedExecution(Runnable r, ThreadPoolExecutor executor);&#125; 任务拒绝处理策略。在源码中定义了如下几种策略： AbortPolicy (默认策略) 12345678public static class AbortPolicy implements RejectedExecutionHandler &#123; public AbortPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; throw new RejectedExecutionException("Task " + r.toString() + " rejected from " + e.toString()); &#125; &#125; 该策略 直接抛出了异常。异常中止 CallerRunsPolicy 12345678public static class CallerRunsPolicy implements RejectedExecutionHandler &#123; public CallerRunsPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; if (!e.isShutdown()) &#123; r.run(); &#125; &#125;&#125; 在线程池未关闭时，直接在当前线程执行任务。所谓当前线程，即提交任务时的线程 DiscardPolicy 12345public static class DiscardPolicy implements RejectedExecutionHandler &#123; public DiscardPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; &#125;&#125; 不做任何处理，即跳过任务r DiscardOldestPolicy 123456789public static class DiscardOldestPolicy implements RejectedExecutionHandler &#123; public DiscardOldestPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; if (!e.isShutdown()) &#123; e.getQueue().poll(); e.execute(r); &#125; &#125;&#125; 在线程池未关闭时，移除处于队头的任务，再执行任务r。相当于把之前队头的任务跳过了，把r又加入了队列 ​ ​ 参数对线程池任务调度的影响当任务数大于等于corePoolSize，这时，除核心线程执行了一定数量的任务后， 余下的需要执行的任务数为int count = tasksCount - corePoolSize，设队列最大容量为capacity： 若capacity &gt;= count，则只会创建corePoolSize个线程来执行任务。多的任务放在队列中。 这时maxPoolSize，就无效了 若capacity &lt; count，这时有int remain = tasksCount - capacity： 若 remain &lt;= maxPoolSize，创建remain个线程来执行任务。多的任务放在队列中 若remain &gt; maxPoolSize，创建maxPoolSize个线程来执行任务；这时将有remain-maxPoolSize个任务无法加入队列，被RejectedExecutionHandler处理。 ​ Executors生成ThreadPoolExecutor(most from http://dongxuan.iteye.com/blog/901689) 在构建时，corePoolSize、maximumPoolSizes 和BlockingQueue的选择，直接影响线程调度的策略 Executors 有三个方法可以生成 ThreadPoolExecutor 生成一个固定线程数的 ThreadPoolExecutorpublic static ExecutorService newFixedThreadPool(int nThreads) { ​ return new ThreadPoolExecutor(nThreads, nThreads, ​ 0L, TimeUnit.MILLISECONDS, ​ new LinkedBlockingQueue()); } LinkedBlockingQueue实现是线程安全的，实现了先进先出等特性，是作为生产者消费者的首选，LinkedBlockingQueue 可以指定容量，也可以不指定，不指定的话，默认最大是Integer.MAX_VALUE，其中主要用到put和take方法，put方法在队列满的时候会阻塞直到有队列成员被消费，take方法在队列空的时候会阻塞，直到有队列成员被放进来。在ThreadPoolExecutor中主要使用的是BlockingQueue的offer()和 poll()、take() LinkedBlockingQueue 无界队列 生成一个只含一个线程的ThreadPoolExecutorpublic static ExecutorService newSingleThreadExecutor() { ​ return new FinalizableDelegatedExecutorService ​ (new ThreadPoolExecutor(1, 1, ​ 0L, TimeUnit.MILLISECONDS, ​ new LinkedBlockingQueue())); } LinkedBlockingQueue 无界队列 生成一个无界的并直接提交的ThreadPoolExecutorpublic static ExecutorService newCachedThreadPool() { ​ return new ThreadPoolExecutor(0, Integer.MAX_VALUE, ​ 60L, TimeUnit.SECONDS, ​ new SynchronousQueue()); } 这个线程池根据需要（新任务到来时）创建新的线程，如果有空闲线程则会重复使用，线程空闲了60秒后会被回收 SynchronousQueue 的特点是，每个插入操作必须等待另一个线程的对应移除操作。比如，要添加一个元素，接下来如果继续想尝试添加则会阻塞，直到另一个线程取走一个元素，反之亦然 SynchronousQueue 不会保留任务进队列，会直接提交到工作线程。 如果当前没有可工作线程，那么在 corePoolSize&lt;maxPoolSize时，会直接创建出新的线程以执行任务 SynchronousQueue 直接提交策略 关于工作队列(workQueue)：所有 BlockingQueue 都可用于传输和保持提交的任务。可以使用此队列与池大小进行交互： 如果运行的线程少于 corePoolSize，则 Executor 始终首选添加新的线程，而不进行排队。（什么意思？如果当前运行的线程小于corePoolSize，则任务根本不会存放，添加到queue中，而是直接开始运行thread。 如果运行的线程等于或多于 corePoolSize，则 Executor 始终首选将请求加入队列，而不添加新的线程。 如果无法将请求加入队列，则创建新的线程，除非创建此线程超出 maximumPoolSize，在这种情况下，任务将被拒绝。 排队有三种通用策略： 直接提交。工作队列的默认选项是 SynchronousQueue，它将任务直接提交给线程而不保持它们。在此，如果不存在可用于立即运行任务的线程，则试图把任务加入队列将失败，因此会构造一个新的线程。此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。直接提交通常要求无界 maximumPoolSizes 以避免拒绝新提交的任务。当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。 无界队列，即队列容量超出余下任务量。使用无界队列（例如，不具有预定义容量的 LinkedBlockingQueue）将导致在所有 corePoolSize 线程都忙时新任务在队列中等待。这样，创建的线程就不会超过 corePoolSize。（因此，maximumPoolSize 的值也就无效了。）当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列；例如，在 Web 页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。 有界队列，即队列容量小于余下任务量。当使用有限的 maximumPoolSizes 时，有界队列（如 ArrayBlockingQueue或具有预定义容量的 LinkedBlockingQueue）有助于防止资源耗尽，但是可能较难调整和控制。队列大小和最大池大小可能需要相互折衷：使用大型队列和小型池可以最大限度地降低 CPU 使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。如果任务频繁阻塞（例如，如果它们是 I/O 边界），则系统可能为超过您许可的更多线程安排时间。使用小型队列通常要求较大的池大小，CPU 使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量。 ​]]></content>
      <categories>
        <category>java多线程</category>
      </categories>
      <tags>
        <tag>ThreadPool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava1.x 你需要了解的]]></title>
    <url>%2F2017%2F05%2F11%2Frxjava%201.x%2F</url>
    <content type="text"><![CDATA[RxJava 1.x RxJava扩展了观察者模式的语义，添加了两个新的操作接口： onCompleted() 通知观察者，Observable没有更多的数据了 onError() 观察到有错误出现了 而onNext() 将被观察者生产的事件通知到观察者 RxJava 1.x的四种基本角色 Observable Observer Subscriber Subject 其中，Observable和Subject是两个”生产”(被观察者)的实体，Observer和Subscriber是两个”消费”(观察者)的实体。其中Observable、Observer是两个基础角色。 Subscriber实现了Observer，并且还添加了一个onStart()，它会在 subscribe 刚开始，而事件还未发送之前被调用，可以用于做一些准备工作。 Subject = Observable + Observer 下图描述Subject与Observer的一对多关系： Obsrvable的变种 —— SingleObservable还有一个变种，就是Single，它总是只发射一个事件，或者一个错误通知 订阅Single只需要两个方法： onSuccess - Single发射单个的值到这个方法 onError - 如果无法发射需要的值，Single发射一个Throwable对象到这个方法 了解就行了，用法与Observable差不多 热的、冷的 Observables热的：Observable只要一创建，就会立即开始emit(发射)数据。后续的订阅它的观察者，可能从序列中间的某个位置开始接受数据(有一些数据错过了)冷的：Observable创建后，一直在等待，直到有观察者订阅它才开始emit数据 Subject = Observable + ObserverSubject，既是一个Observable，也是一个Observer。 可以emit数据，可以subscribe 一个Observable或其它Subject。 RxJava 提供四种不同的 Subject: PublishSubject BehaviorSubject ReplaySubject AsyncSubject UnicastSubject SerializedSubject ###PublishSubject是Subject的一个子类，它通过create()创建实例。它是一个”冷的”Observable。直到触发它的onNext(T t)，才开始emit数据，并完成订阅。可用于实现类似EventBus的RxBus。 ###BehaviorSubject是Subject的一个子类，它通过create()创建实例。首先会向它的订阅者发送截止订阅前的最后一条数据流，然后才正常发送订阅后的数据流。 123456789101112131415161718192021222324252627282930&#123; // observer will receive all 4 events (including "default"). BehaviorSubject&lt;Object&gt; subject = BehaviorSubject.create("default"); subject.subscribe(observer); subject.onNext("one"); subject.onNext("two"); subject.onNext("three"); // observer will receive the "one", "two" and "three" events, but not "default" and "zero" BehaviorSubject&lt;Object&gt; subject = BehaviorSubject.create("default"); subject.onNext("zero"); subject.onNext("one"); subject.subscribe(observer); subject.onNext("two"); subject.onNext("three"); // observer will receive only onCompleted BehaviorSubject&lt;Object&gt; subject = BehaviorSubject.create("default"); subject.onNext("zero"); subject.onNext("one"); subject.onCompleted(); subject.subscribe(observer); // observer will receive only onError BehaviorSubject&lt;Object&gt; subject = BehaviorSubject.create("default"); subject.onNext("zero"); subject.onNext("one"); subject.onError(new RuntimeException("error")); subject.subscribe(observer);&#125; ReplaySubject缓存订阅的数据，重发给订阅它的观察者 12345ReplaySubject&lt;String&gt; subject = ReplaySubject.create();subject.onNext("haha1");subject.onNext("haha2");subject.onNext("haha3");subject.subscribe(s -&gt; System.out.println("rss1" + s)); AsyncSubject仅在Observable完成之后，发送最后一条数据给观察者。 然而如果当Observable因为异常而终止，AsyncSubject将不会释放任何数据，但是会向Observer传递一个异常通知。 123456AsyncSubject&lt;String&gt; subject = AsyncSubject.create();subject.onNext("haha1");subject.onNext("haha2");subject.onNext("haha3");subject.onCompleted();subject.subscribe(s -&gt; System.out.println("ass1" + s)); UnicastSubject只允许有一个 Subscriber 订阅(内部subscribeActual()，用到了AtomicBoolean 判断，第二次无就抛出异常) 123456UnicastSubject subject = UnicastSubject.create();subject.onNext("haha1");subject.onNext("haha2");subject.onNext("haha3");subject.onCompleted();subject.subscribe(s -&gt; System.out.println("uss1" + s)); SerializedSubject当我们使用普通的Subject，必须要注意不要在多线程情况下调用onNext方法，而使用SerializedSubject封装原来的 Subject即可！！内部使用了SerializedObserver。查看其doc，如果是多线程环境，即有多个线程发射通知时，它们将被按序列执行：1.允许仅有一个线程，执行一个emit2.如果另一线程，已经emit，将下一个添加到通知队列3.在循环emitting时，不持有任何锁或阻塞任何线程 1234567891011ReplaySubject&lt;String&gt; subject = ReplaySubject.create();SerializedSubject&lt;String, String&gt; serializedSubject = new SerializedSubject&lt;&gt;(subject);serializedSubject.subscribe(s -&gt; System.out.println("thread-" + Thread.currentThread().getName() + "--" + s));for (int i = 0; i &lt; 10; i++) &#123; int finalIndex = i; new Thread(() -&gt; serializedSubject.onNext("haha" + finalIndex)).start();&#125;serializedSubject.onNext("haha20");serializedSubject.onNext("haha21");serializedSubject.onNext("haha22"); RxJava操作符(most from http://frodoking.github.io/2015/09/08/reactivex/) 大多数操作符：操作一个Observable并且返回一个Observable。 这样允许开发人员以一个链式的方式一个接一个的执行操作符。 在可修改的链式中，每一个操作结果Observable都是来之于上一个操作。 这里有一些类似于构造器Builder模式，该模式描述了一个含有一系方法的特定类通过操作方法来操作具有相同功能的类的每一项。 这个模式也允许你以类似的方式去链式操作方法。在Builder模式中，操作方法出现的顺序在链式中可能不是那么重要， 但是在Observable中的操作符顺序就很重要。 Observable操作符链不会依赖于原来的Observable去操作原始的链，每一个在Observable上的正在操作的operator都是上一个操作立即产生的。 创建Observable – 创建新的Observable的操作符 create——从头创建一个Observable，当观察者订阅Observable时，它作为一个参数传入，并执行call() defer——不立即创建Observable，直到observer触发订阅动作。此方法为每一个observer创建一个新的Observable empty/never/error——为非常精确和有限的行为而创建Observable：空的，不emit数据/不emit数据，且永远不会结束/不emit数据，以onError()结束 from——迭代一个序列(集合或数组)，一个一个的发射数据 interval——创建一个具有发出一个整数序列间隔为一个特定的时间间隔的Observable just——按顺序emit后面跟的”1到9个”数据 range——创建一个Observable,发送一系列连续的整数 repeat——创建一个Observable,发送一个特定的项目或项目重复序列 timer——创建一个Observable,在一个给定的一段时间延迟后发送一个对象或者项目 ​ 转换Observables – 转换成另一个Observable的操作符 buffer——定期收集从Observable中发出的数据到集合中，每次发射一组，而不是发送一个 concatMap——与flatMap非常相似。但它会将展开的元素，一个个有序的连接起来 flatMap——将一个Observable发送的数据或者项目转换到Observables中，适用于将 T 变换为 Observable，Observable表示一个序列集。发送的次序可能是交错的 flatMapIterable——与flatMap类似，只是它会将数据转换成一个Iterable groupBy——拆分一个Observable成多个Observable组，并且每个组发送的数据会组成一个不同的发送数据组当然这些发送数据时来自于原始的Observable。这些分组都是通过划分key来实现 map——转换一个Observable发送的每个数据或者项目映射到一个函数上 scan——应用一个函数给一个Observable发送出来的每一条数据, 并且是按照顺序发送每个连续值(t1,t2, return R) switchMap——与flatMap类似，除了一点: 当源Observable发射一个新的数据项时， 如果旧数据项订阅还未完成，就取消旧订阅数据和停止监视那个数据项产生的Observable,开始监视新的数据项 window——类似buffer，但发射的是一个Observable，而不是列表 lift——针对事件项和事件序列的操作符。对于事件项的类型转换，主要在一个新的Subscriber中完成。 compose——需要一个Observable.Transformer型的入参。该类型的call()，操作的是一个Observable，并返回另一个Observable。所以compose用于在内部组合一组变换的场景。 过滤Observables – 过滤被Observable发送的数据的操作符 debounce——如果Observable在一个特定时间间隔过去后没有发送其他数据或者项目,那么它只发送最后那个 distinct——该Observable不可以发送重复的数据 distinctUntilChanged——发送”跟上一个数据不重复”的新值 elementAt——只发送可观测序列中的某一项。index从0开始 filter——一个Observable只发送通过来特定测试描述语的匹配项 first——只发出第一项,或第一项符合条件的项 ignoreElements——不发送任何数据，但是必须反馈它的中断通知: Observable的onCompleted和onError事件 last——只发送最后一项 sample——发出Observables周期时间间隔内最新的项 throttleFirst——发出Observables周期时间间隔内的第一项 throttleLast——发出Observables周期时间间隔内的最后一项 skip——跳过发送前几项 skipLast——跳过发送后几项 take——仅仅发送前几项 takeLast——仅仅发送后几项 合并Observables – 将多个Observables合并成单个的Observable的操作符 combineLatest——当某一项数据由两个Observables发送时，通过一个特殊的函数来合并每一个Observable发送的项，并且最终发送数据是该函数的结果 join——合并两个Observables发送的结果数据。其中两个Observable的结果遵循如下规则： 每当一个Observable在定义的数据窗口中发送一个数据都是依据另外一个Observable发送的数据。 merge——通过合并多个Observables发送的结果数据将多个Observables合并成一个 mergeDelayError——即使发生了error也不打断merge操作，当所有merge结束后，才发射onError() startWith——在Observable源开始发送数据项目之前，先发送一个指定的项目序列 zip——它使用这个函数按顺序结合两个或多个Observables发射的数据项，然后它发射这个函数返回的结果。它按照严格的顺序应用这个函数。它只发射与发射数据项最少的那个Observable一样多的数据。 zipWith——与zip类似，只是一个成员方法，必须由一个Observable来发起。 错误处理操作符（most from http://www.jianshu.com/p/5bb3e55a14c4） retry——如果一个源Observable发送一个onError通知，需要重新发射，以期望不发生错误。 有三个变体方法：retry() 若有错，一直重新发射，直到无错误； retry(count) 若有错，只重新发射count次，直到无错误；retry(new Func2(){…}) ，三个参数的意思是，正常接收到的值, 发生的异常, 在发生错误时是否要重新发射，重写函数返回值 false 不重新发射。 retryWhen——retryWhen类似retry。如果发射一个error，会传递给其观察者，并交由retryWhen中的Func1来操作，Func1又由Func2组成。Func2的call函数的返回值决定订阅过程是否重复发生：如果发射的error，订阅会终止，如果发射的是数据项，则会重新订阅 onErrorReturn——若源Observable发生了错误或异常，替代源Observable调用Observer的onError方法。onErrorReturn中那个Func1实现被调用并接受这个错误或异常作为参数，这个Func1实现的返回值将作为onErrorReturn返回的值 onErrorResumeNext——源Observable遇到错误，这个onErrorResumeNext会把源Observable用一个新的Observable替掉，然后这个新的Observable如果没遇到什么问题就会释放item给Observer。你可以直接将一个Observable实例传入onErrorResumeNext作为这个新的Observable，也可以传给onErrorResumeNext一个Func1实现，这个Func1实现接受源Observable的错误作为参数，返回新的Observable onExceptionResumeNext——与onErrorResumeNext类似。只是onExceptionResumeNext是在发生了Exception时，才触发。如果发生的不是一个Exception，仍会触发Observer的onError方法 实用工具操作符 delay——按照一个特定量及时的将Observable发送的结果数据向前推移 do——注册一个事件去监听Observable生命周期 doOnSubscribe在Subscriber#onStart()时回调 doOnNext在Observer#onNext()时回调 doOnError在Observer#onError()时回调 doOnCompleted在Observer#onCompleted()时回调 doOnEach在Observer#onNext()、onError()、onCompleted()时都会回调 materialize/Dematerialize——代表发送出来的项目数据或者通知，或相反过程 observeOn——指定一个observer将会观察这个Observable的调度 serialize——强制Observable按次序发射数据并且要求功能是完好的 subscribe——操作可观测的排放和通知 subscribeOn——指定一个Observable在被订阅的时候应该使用的调度 timeInterval——转换一个Observable的发送项目到另一个项目，在这些发送项之间，此项目具有指示这些发送的时间开销功能 timeout——镜像源Observable,但如果某段时间过后没有任何通知发出将会发出一个错误通知 timestamp——给一个Observable发送的每一个项目附加一个时间戳 using——创建一个一次性的资源，这个资源就像Observable一样有相同的寿命 条件和布尔运算操作符 – 评估一个或者多个Observables或者被Observables发送的项目的操作符 all——确定发出的所有项目满足某些标准 amb——给定一组Iterable来源，只发射第一个Observable的数据 contains——判断Observable是否包含一个特定的项 defaultIfEmpty——发送项从Observable源，或者如果Observable源没有任何发送内容，那么将会发送一个默认的项 sequenceEqual——确定两个Observables发出相同的序列条目 skipUntil——丢弃Observable发出的项,直到第二个Observable发出一项 skipWhile——丢弃Observable发出的项,直到指定的条件变成了false takeUntil——在第二个Observable发送一项或者终止之后，丢弃Observable发出的项 takeWhile——在指定的条件变成了false之后，丢弃Observable发出的项 类型转换操作符 to——将一个Observable转换到另一个对象或数据结构。 toXxx cast——传入其它类型Class，进行自动转换 可连接到Observable的操作符 – 指定Observables有更多精确控制订阅动态的操作符 connect——定义一个可连接的Observable发送项目数据给它的订阅者 publish——把一个普通的Observable转化为一个可连接的Observable（向下转换） replay——返回一个Connectable Observable 对象并且可以缓存其发射过的数据，这样即使有订阅者在其发射数据之后进行订阅也能收到其之前发射过的数据。不过使用Replay操作符我们最好还是限定其缓存的大小，否则缓存的数据太多了可会占用很大的一块内存。对缓存的控制可以从空间和时间两个方面来实现，比如它的其它变体实现：replay(int bufferSize)、replay(int bufferSize, long time, TimeUnit unit) … 数学操作符(For details, please see RxJavaMath and Mathematical-and-Aggregate-Operators) 主要使用MathObservable来操作数据 average——计算一个Observable发送所有结果的平均值，并且发射这个值 对应的变体有averageDouble、 averageFloat、 averageInteger、 averageLong max——确定,发射最大值项 min——确定,发射最小值项 sum——计算Observable发射的所有数据的求和，并且发射这个求和结果 对应的变体有sumDouble、sumFloat、sumInteger、sumLong 以上方法，都有静态与非静态方法。静态方法要求传入一个Observable；非静态方法可通过from(Observable observable)返回一个MathObservable，来进行操作。 聚集操作符(most from http://blog.csdn.net/jdsjlzx/article/details/51489793) concat——顺序连接多个Observables,并且严格按照发射顺序，前一个没有发射完，是不能发射后面的 count/countLong——计算Observable源发出的项目数据数量，并发出这个值 reduce——应用一个函数接收Observable发射的数据和函数的计算结果作为下次计算的参数，输出最后的结果。 跟scan操作符很类似，只是scan会输出每次计算的结果，而reduce只会输出最后的结果。 collect——将原始Observable发射的数据放到一个单一的可变的数据结构中，然后返回一个发射这个数据结构的Observable toList——收集原始Observable发射的所有数据到一个列表，然后返回这个列表 toSortedList——收集原始Observable发射的所有数据到一个有序列表，然后返回这个列表 toMap——将序列数据转换为一个Map，Map的key是根据一个函数计算的 toMultiMap——将序列数据转换为一个列表，同时也是一个Map，Map的key是根据一个函数计算的 toBlocking——转换成一个BlockingObservable。当满足条件的数据发射出来的时候才会返回一个BlockingObservable对象 #Schedulers 线程调度 在没有给定调度器（Scheduler）的情况下，Subscription将默认(产生事件与订阅)运行于调用线程上。 线程调度器（Scheduler）是将RxJava从同步观察者模式转到异步观察者模式的一个重要工具。 RxJava提供了5种主要的调度器: Scheduler Schedulers.io() Scheduler Schedulers.computation() Scheduler Schedulers.immediate() Scheduler Schedulers.newThread() Scheduler Schedulers.trampoline() 还有可用于测试的调度器Schedulers.test() 及 可自定义Scheduler—-Schedulers.form() Schedulers.io()内部创建一个rx.internal.schedulers.CachedThreadScheduler。底层实现是一个java中的ScheduledThreadPoolExecutor (extends ThreadPoolExecutorimplements ScheduledExecutorService) 12345public ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory) &#123; super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, new DelayedWorkQueue(), threadFactory);&#125; corePoolSize=1, DEFAULT_KEEPALIVE_MILLIS=10L, DelayedWorkQueue是一个二叉树结构实现的BlockingQueue 整体还是一个无界(即容量特别大)的队列实现 例如，存储Bitmap到本地时，可以直接在Schedulers的io线程中执行任务： 12345public static void storeBitmap(Context context, Bitmap bitmap, String filename) &#123; Schedulers.io().createWorker().schedule(() -&gt; &#123; blockingStoreBitmap(context, bitmap, filename); &#125;); &#125; Schedulers.computation()内部是由 rx.internal.schedulers.EventLoopsScheduler 实现的。 这个是计算工作默认的调度器，它与I/O操作无关。它也是许多RxJava方法的默认调度器: buffer()、debounce()、delay()、interval()、sample()、skip() Schedulers.immediate()内部创建一个rx.internal.schedulers.ImmediateScheduler。 这个调度器允许你立即在当前线程执行指定的工作。 它是 timeout()、timeInterval() 及 timestamp() 方法默认的调度器 Schedulers.newThread()内部创建一个rx.internal.schedulers.NewThreadScheduler。一底层跟Schedulers.io()一样是由java的ScheduledThreadPoolExecutor实现。 它为指定任务启动一个新的线程 Schedulers.trampoline()内部创建一个rx.internal.schedulers.TrampolineScheduler。运行在当前线程。当有新任务时，并不会立即执行，而是将它加入队列PriorityBlockingQueue中，直到运行任务执行完成后，才从队列中按序取出一个继续执行。 它是repeat()和retry()默认的调度器 用于测试的调度器Schedulers.test()(some from http://blog.csdn.net/siguoyi/article/details/51849964) 创建一个rx.schedulers.TestScheduler。这是一个公开的可访问的类。也可以直接使用无参构造方法，new出一个实例。 主要提供如下三个方法，来对调度器的时钟表现进行手动微调，这对依赖精确时间安排的任务的测试很有用处。 advanceTimeBy(time,unit) 将调度器时时钟，前进一个指定时间。这是相对操作 advanceTimeTo(time,unit) 将调度器时钟拨动到一个指定的时间。 这个是绝对操作 triggerActions( ) 开始执行任何计划中的但是未启动的任务，如果它们的计划时间等于或者早于调度器时钟的当前时间 假定当前时间为0， 先advanceTimeBy(2, TimeUnit.SECONDS)再advanceTimeTo(2, TimeUnit.SECONDS)，那么现在时间还是2。若反过来调用，那么现在时间就是4b了 自定义Scheduler—-Schedulers.form()使用Schedulers.form(java.util.concurrent.Executor executor) ，来自定义Scheduler subscribeOn()和observeOn()subscribeOn()和observeOn() 是用来指定事件生产与订阅在哪个线程执行的。 默认没有定义observeOn、subscribeOn，即运行于当前线程 subscribeOn 指定 订阅事件发生(OnSubscribe)的线程。若仅出现它，不出现observeOn, 还会影响其它所有事件 observeOn 指定 在其之后的所有事件发生的线程，即使后面出现了 subscribeOn 若两者同时出现，subscribeOn 影响 observeOn 出现前的所有事件 及 OnSubscribe 事件 12345678910Action1 action = (Action1&lt;String&gt;) s -&gt; System.out.println("test-Observer: " + Thread.currentThread().getName() + ", " + s);Observable.Transformer&lt;Integer, String&gt; transformer = integerObservable -&gt; integerObservable.map((Func1&lt;Integer, String&gt;) integer -&gt; "test-tran.call: " + Thread.currentThread().getName() + ", " + integer);Observable.create((Observable.OnSubscribe&lt;Integer&gt;) subscriber -&gt; &#123; System.out.println( "test-OnSubscribe.call: " + Thread.currentThread().getName()); subscriber.onNext(9); &#125;).subscribeOn(io()).observeOn(AndroidSchedulers.mainThread()).compose(transformer).subscribe(action); 背压(Backpressure)(most from https://zhuanlan.zhihu.com/p/24473022?refer=dreawer) 背压是指在异步场景中，被观察者发送事件速度远快于观察者的处理速度的情况下，一种告诉上游的被观察者降低发送速度的策略。简而言之，背压是流速控制的一种策略。 若被观察者发送事件的速度太快，而观察者处理太慢，而且还没有做相应背压措施，可能抛出MissingBackpressureException 压力异常示例12345Observable.interval(1, TimeUnit.MILLISECONDS) .observeOn(Schedulers.newThread()) .subscribe(aLong -&gt; &#123; Log.w("TAG","----&gt;"+aLong); &#125;); 上面的interval操作符，在1毫秒产生一个事件，速率过快，订阅者”消费”事件来不及处理，就会出现异常。 自带背压处理的操作符用自带背压处理的操作符来处理压力。 过滤策略使用之前讲的”过滤操作符”，就可以有效缓解压力。 比如，使用throttleFirst来获取一段周期时间内的首个事件。 123456Observable.interval(1, TimeUnit.MILLISECONDS) .observeOn(Schedulers.newThread()) .throttleFirst(200, TimeUnit.MILLISECONDS) .subscribe(aLong -&gt; &#123; Log.w("TAG","----&gt;"+aLong); &#125;); 缓存策略缓存就是虽然被观察者发送事件速度很快，观察者处理不过来，但是可以选择先缓存一部分，然后慢慢读。 主要用到的是buffer操作符 1234567Observable.interval(1, TimeUnit.MILLISECONDS) .observeOn(Schedulers.newThread()) //这个操作符简单理解就是把100毫秒内的事件打包成list发送 .buffer(100,TimeUnit.MILLISECONDS) .subscribe(aLong -&gt; &#123; Log.w("TAG","----&gt;"+aLong); &#125;); 按需拉取策略就是需要”消费”多少个事件，自己告诉被观察者，最终实现了上游被观察者发送事件的速度的控制 主要使用request(long n)。这是一个protected方法 123456789101112131415161718192021222324252627Observable.range(100, 10000)//从100开始，发送10000个数，即最后发送10100 .observeOn(Schedulers.newThread()) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onStart() &#123; super.onStart(); //在onStart中通知被观察者先发送一个事件 request(1); &#125; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(Integer integer) &#123; Log.w("TAG","----&gt;"+ integer); request(1); //处理完毕之后，再通知被观察者发送下一个事件 &#125; &#125;); 上面的代码中，其实可以去掉request相关代码，因 range –&gt; observeOn，这一段过程本身就是响应式拉取数据。 observeOn这个操作符内部有一个缓冲区RxRingBuffer，其在Android环境下长度是16，它会告诉range最多发送16个事件，充满缓冲区即可 让不支持背压的Observable“支持”背压对于不支持背压的Observable除了使用上述两类生硬的操作符之外，还有更好的选择：onBackpressureBuffer、onBackpressureDrop。 onBackpressurebuffer：把Observable发送出来的事件做缓存，当request方法被调用的时候，给下层流发送一个item(如果给这个缓存区设置了大小，那么超过了这个大小就会抛出异常)。 onBackpressureDrop：将Observable发送的事件抛弃掉，直到Subscriber再次调用request（n）方法的时候，就发送给它这之后的n个事件。 使用了这两种操作符，可以让原本不支持背压的Observable“支持”背压了。 123456Observable.interval(1, TimeUnit.MILLISECONDS) .onBackpressureBuffer() .observeOn(Schedulers.newThread()) .subscribe(aLong -&gt; &#123; Log.w("TAG--","----&gt;"+aLong); &#125;);]]></content>
      <categories>
        <category>Android开源库</category>
      </categories>
      <tags>
        <tag>RxJava1.x</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 操作指南]]></title>
    <url>%2F2017%2F03%2F17%2Fgit%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[前言 git这个版本控制工具，早在两三年前我就开始使用了。不过后来换了新东家后，又开始变成了svn，最近又切成git了。通过近期的使用，遇到了一些坑，遂引发此文，以作记录 issue：某个commit整体不要了，想重置？add多了，想撤销？某个文件有问题，想还原到某次commit时的状态？想push到另外的远程仓库？什么！这行代码是哪个鬼加进去的，引起了bug？咦，这个bug，在好几个版本都存在，是哪次commit引起的？… 本文都能找到答案 注：可以通过上面的目录，来选取自己感兴趣的内容，进行查看 下载安装 链接：https://git-scm.com/download 下载首页https://git-scm.com/download/winhttps://git-scm.com/download/linuxhttps://git-scm.com/download/machttps://git-scm.com/downloads/guis/ GUI工具 mac下还可以通过brew安装，再配合zsh的git短命令插件，来玩。 下载安装好后，打开命令行，运行：git --version查看版本号，以确保git可用。如提示找不到命令git，请将其安装目录下的可执行文件(git.exe 或 就叫git)父目录路径，添加到环境变量中。 生成密钥命令：​12ssh-keygen -t rsa -C &quot;aa86799@163.com&quot;​ 回车后会弹出提示：​123Generating public/private rsa key pair.Enter file in which to save the key (/Users/stone/.ssh/id_rsa):​ 意思是：创建公钥/私钥文件，请键入文件的保存地址。默认直接回车就会生成在/Users/stone/.ssh/ 下，私钥文件名：id_rsa，公钥文件名：id_rsa.pub。密钥目录，一般都是在 users&gt;user&gt;.ssh 下。windows中为：C:\Users\Administrator.ssh 也可以在输入创建命令时直接指定目录：​12ssh-keygen -t rsa -f ~/.ssh/id_rsa.github -C &quot;aa86799@163.com&quot;​ 回车后，会提示：​12Enter passphrase (empty for no passphrase): ​ 意指，输入密码。不输，也可以，直接回车就行。然后会提示让你再输入一次密码。输入后，再回车，就会生成相应的密钥文件，在指定的目录位置。 查看公钥一般我们要把公钥，上传到服务器。找到.pub结尾的公钥文件。以命令行打开(mac/linux 用cat命令)，或用文本文件打开，复制出来，上传即可类似内容：​123ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDfCwawUX/Milxu29sH5kZPFWWPoe/… aa86799@163.com​ 配置 设置user name 、email设置Git的user name和email，用于显示在版本提交记录中：123git config --global user.name &quot;stone&quot; git config --global user.email &quot;aa86799@163.com&quot; --后可选 global、system、local global 影响范围：系统用户下全局system 影响范围：系统下全局local 影响范围：当前项目下 我一般的做法是，进入项目目录后，采用local来配置。因为对应多个git服务端，我想设置不同的邮件和名字。更多参见自定义 Git - 配置 Git 配置.ssh/config上面的命令执行后，会在.ssh目录下生成一个config文件。当然，不执行命令，也可以在其下，手动创建一个名为config的空文件。 如下，我配置了github和oschina：​12345678Host github.com IdentityFile ~/.ssh/id_rsa.github User gitHost oschina.net IdentityFile ~/.ssh/oschina_id_rsa User git​ 一些可选配置参数说明： Host github.com #主机名IdentityFile ~/.ssh/id_rsa.github #公钥文件User git #连接服务器的用户名hostname www.github.com #服务器ip地址，也可以是域名Port 5566 #服务器端口号RSAAuthentication yes # 采用RSA加密认证PubkeyAuthentication yes #采用公钥认证 配置后，在本地与server的交互时，git才知道用哪一种具体的config。 git仓库 本地新建仓库进入本地文件目录，一般就是某个项目的工程目录下，执行： 1git init 会生成一个.git目录 关联远程仓库比如关联github。需要先在github上建立一个repository，比如名为：MyActionBar 再进入项目根目录，键入命令，关联远程仓库：1git remote add origin git@github.com:aa86799/MyActionBar.git git clone远程仓库比如clone 一个github上的项目，命令：​123git clone https://github.com/googlesamples/android-architecture.git #直接clone出名为android-architecture的项目​ 后跟一个指定的项目名字：​12git clone https://github.com/googlesamples/android-architecture.git myArchi #clone出一个名myArchi的项目​ 配置本地user name 、email配置命令：12git config --local user.name &quot;stone&quot; git config --local user.email &quot;aa86799@163.com&quot; 会在.git中的config文件中添加如下内容： 123[user] name = stone email = aa86799@163.com git 别名，短命令如果不想每次都输入完整的 Git 命令，可以通过 git config 文件来轻松地为每一个命令设置一个别名。如：​12345$ git config --global alias.co checkout$ git config --global alias.br branch$ git config --global alias.ci commit$ git config --global alias.st status​ 再例如，为了解决取消暂存文件的易用性问题，可以向 Git 中添加你自己的取消暂存别名：​12git config --global alias.unstage &apos;reset HEAD --&apos;​ 这会使下面的两个命令等价：​123$ git unstage fileA$ git reset HEAD -- fileA​ 注：别名时，不能把git也放进去。当然有些脚本插件是可以的。后文还有diff与merge工具的相关配置 版本控制操作 以下罗列一些常用的命令操作与选项。 下文中， 符号[ ]表示，命令后跟的内容，实际使用时，不需要符号[ ]。 branch 分支仓库建好后，默认为master分支 分支的好处：如在svn中，每次开发一个新版本，都要新创建一个分支的目录，复制所有项目文件进去；而在git中只要创建一个新的分支，会瞬间创建成功。还可以创建本地分支，进行自己的想要一些改动，只要不push到远程，就不会影响服务端项目。 分支相关常用命令： 查看本地所有分支：1git branch 当前所在分支前面，会有一个星号(*) 查看本地和远程所有分支：1git branch -a 显示分支更多信息-v选项，会输出分支的最后提交记录 1git branch -v 显示分支更多信息，包括关联的远程分支信息 1git branch -vv 创建本地分支(从当前分支最后commit)： 1234git branch [newBranch]git checkout -b [newBranch] #创建并切换到新分支git checkout -b [newBranch 9510eee]#从当前分支的某次commit记录为9510eee处，创建新分支，并切换到新分支git branch [newBranch 9510eee] #从commit记录为9510eee处，创建新分支 创建与远程分支相关联的本地分支： 123#检出远程master分支 到 本地分支 newBranchgit branch [newBranch remote/master]git checkout -b [newBranch remote/master] #创建并切换到新分支 删除分支： 1git branch -d [specifiedBranch] 如果报错：error: The branch ‘a2’ is not fully merged.If you are sure you want to delete it, run ‘git branch -D a2’.表示分支a2有新的提交，但没有完整的合并到其他分支上。如果想要删除，需要使用命令：git branch -D a2 切换分支：1git checkout [branchName] 注：分支切换时，要注意，如果本地有修改未commit或stash，需要先commit或stash 分支合并 这部分内容放到下文#merge中 查看分支提交信息 1git show-branch [develop] #后不跟，则查看所有分支的提交信息 tag 标签一般，项目的每个release稳定版，都要求有一个tag标签 常用命令， 显示当前所有标签：​12git tag​ 查找标签​12git tag -l &apos;v1.8.5*&apos; #查找前缀为v1.8.5的所有分支​ 创建标签，并使用-m 添加说明信息：​12git tag -a [v1.1] -m [v1.1 release version] #可以没有-m，但一般还是加上好​ 若想对过去的某次commit打tag：​12git tag -a [v0.8 077d7ad] -m [&quot;v0.8&quot;] #-m时有没有双引号都可以​ 共享标签默认情况下，git push 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样，你可以运行​123git push origin [tagname]#推送某个tag到origingit push origin --tags #把所有不在远程仓库服务器origin上的标签全部传送​ 删除标签：​1234git tag -d [tagName] #删除本地git tag -d -D [tagName] #强制删除本地taggit push [origin] --delete tag [tagName]#删除远程origin上的tag​ 从一个标签检出一个新分支：​12git checkout -b [branch_name tag_name]​ status 文件版本状态 查看项目中文件的变动状态：1git status 在输出信息中，会看到(这里只记录了开头修饰词)：12345new file 已加入版本记录，但未commitmodified 修改了版本记录中某文件deleted 删除了版本记录中某文件Untracked files 未加入版本记录(追踪)… 状态简览1git status -s 这里引用一个官方示例，输出如下：123456$ git status -s M README #M在右，前面空了一个字符位置M Rakefile #M在左A lib/git.rbM lib/simplegit.rb?? LICENSE.txt 说明：?? —— Untracked file，未add到版本记录A —— 已add (详见下面的add命令)R —— rename，被重命名了左M —— 新的修改，已add到版本记录右M —— 新的修改，未add到版本记录，如要提交该修改，必须先add左D 、右D —— 类似M，指文件删除记录，是否add到版本记录中 add 加入版本记录将文件加入版本记录。配合status命令，将需要加入版本记录的，有选择的加入。​12git add //后跟目录路径，或某个具体文件路径​ -p选项可以将一个文件的多处修改，分割成多个块来多次提交。​12git add -p [flie] ​ 与-i命令中的暂存补丁效果一样。 -i或–interactive选项使用该选项，Git 将会进入一个交互式终端模式，基本上与 git status 是相同的信息。显示类似下面的东西： ​1234567891011git add -i staged unstaged path 1: +1/-1 nothing a 2: unchanged +1/-0 b*** Commands *** 1: status 2: update 3: revert 4: add untracked 5: patch 6: diff 7: quit 8: helpWhat now&gt; ​ 它将暂存的修改列在左侧，未暂存的修改列在右侧在这块区域后是命令区域。 在这里你可以做一些工作，包括暂存文件、取消暂存文件、暂存文件的一部分、添加未被追踪的文件、查看暂存内容的区别。 a.暂存与取消暂存文件输入2或u，会提示需要暂存(即add)哪个文件，输入数字索引即可暂存。输入3或r，会提示要取消暂存哪个文件若在update或revert状态时，什么也不选，直接输入回车，就会将之前的输入操作执行完，并退出当前状态。 b.暂存补丁输入5或p。会输出第一个未暂存文件的diff信息，类似git add -p [file]的块选择，如：​123456789diff --git a/b b/bindex e69de29..01f02e3 100644--- a/b+++ b/b@@ -0,0 +1 @@+bbb\ No newline at end of fileStage this hunk [y,n,q,a,d,/,e,?]? ​ 输入？可查看更多选项。输入y暂存。然后会继续显示下一个未暂存文件的diff信息… ignore 忽略文件将不需要加入版本记录的文件，进行ignore操作。需要在仓库目录下建立一个 .gitignore 文件(其与.git是平级的)配置语法： 以斜杠“/”开头表示目录，以防止递归；可以以”/“结尾指定目录 以星号“*”通配多个字符； 以问号“?”通配单个字符 以方括号“[]”包含单个字符的匹配列表；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字） 以叹号“!”表示不忽略(跟踪)匹配到的文件或目录； git 对于 .ignore 配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效 rm 移除文件跟踪要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。 不再追踪暂存区文件 如现有一个新文件PROJECTS.md，刚刚进行了add，还未提交过。 如果只是简单地从工作目录中手工删除(rm)文件，运行 git status 时就会在 “Changes not staged for commit” 部分（也就是 未暂存清单）看到：​123456789101112$ rm PROJECTS.md$ git statusOn branch masterYour branch is up-to-date with &apos;origin/master&apos;.Changes not staged for commit: (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) deleted: PROJECTS.mdno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)​ 然后再运行 git rm 记录此次移除文件的操作：​123456789$ git rm PROJECTS.mdrm &apos;PROJECTS.md&apos;$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) deleted: PROJECTS.md​ 下一次提交时，该文件就不再纳入版本管理了。 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被 Git 恢复。场景：对于新文件，刚进行了add，然后又修改了该文件，然后想 用git rm 取消追踪，就需要-f选项了。 从 Git 仓库中删除版本追踪另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当你忘记添加 .gitignore 文件，不小心把一个很大的日志文件或一堆 .a 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 为达到这一目的，使用 –cached 选项：​12git rm --cached -r README​ git rm 命令后面可以列出文件或者目录的名字，也可以使用 glob 模式(指shell所使用的简化了的正则表达式)。 比方说： git rm log/\.log注意到星号 之前的反斜杠 \， 因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用shell 来帮忙展开。 此命令删除 log/ 目录下扩展名为 .log 的所有文件。类似的比如：git rm *~ 该命令为删除以 ~ 结尾的所有文件。 mv 移动文件，重命名比如运行了下面三条命令：123$ mv README.md README$ git rm README.md$ git add README Git 会意识到这是一次改名操作。可以使用如下一条命令，来进行改名操作1git mv [file_from file_to] commit 提交 已add文件，commit 所有改动过的且已加入版本记录的文件，可以使用commit来提交到本地仓库。​12git commit -m [message] [file1] [file2]​ 可以不写commit信息，一般还是建议写。commit哪些文件是可以指定的，中间用空格分隔，需要文件的完整路径。若不指定具体文件，默认为仓库下所有改动过的且已加入版本记录的文件 之前已在版本记录中，修改后未add文件，想直接commit​12git commit -a -m [message] [file1] [file2]​ 添加-a选项，即可 撤销操作有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 –amend 选项的提交命令尝试重新提交：​12git commit --amend​ 例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：​1234$ git commit -m &apos;initial commit&apos;$ git add forgotten_file$ git commit --amend​ 最终你只会有一个提交 —— 第二次提交将代替第一次提交的结果。 注：其他撤销例子见reset cherry-pick 重新提交历史记录用于将已经存在的commit 记录进行 再次提交。1git cherry-pick c9f98b9 如果有冲突，解决冲突后，先add，再commit stash 储存 有时，突然来个紧急任务，需要切换分支，又不想为此单独提交一次。就可以使用stash命令。git会将未完成的修改保存到一个栈上，而你可以在任何时候重新应用这些改动。命令：​1234git stashgit stash save #与上等价git stash save &quot;message&quot; #如果要加上备注信息message，还是要用带save的命令​ 之后，工具目录自动切换成上次提交时的状态。 查看存储栈​12git stash list​ 类似输出：​1234stash@&#123;0&#125;: WIP on master: 049d078 added the index filestash@&#123;1&#125;: WIP on master: c264051 Revert &quot;added file_size&quot;stash@&#123;2&#125;: WIP on master: 21d80a5 added number to log​ 应用储存的任务如上面说到，在其他分支改完问题了，再切换之前分支，来应用储存：​12git stash apply stash@&#123;2&#125; #如果不指定哪一条stash，默认为最近的，即stash@&#123;0&#125;​ 如果，有多个储存，应用一个后(若有冲突，先解决冲突)，先将修改的add进暂存区，再apply其它的。 移除储存​12git stash drop stash@&#123;0&#125;​ 清除所有储存​12git stash clear​ 不储存已add的文件​12git stash --keep-index​ 储存从未add的文件默认情况下，git stash 只会储藏已经在索引(版本记录)中的文件。若要储藏任何创建的未跟踪文件：​123git stash -ugit stash --include-untracked #与-u等价​ 交互式指定要储存的文件​12git stash --patch​ 从储存创建一个分支​12git stash branch testchanges stash@&#123;1&#125;​ push 推送 完整push命令： 1git push [origin localMaster:master]#将本地分支localMaster推送到远程仓库origin的master上 省略远程分支 1git push [origin localMaster]#将本地分支localMaster推送到远程仓库origin上，如果远程不存在，则创建 省略本地分支 1git push [origin :master]#推荐一个空分支到origin/master，当然origin/master就为空了。 push时指定当前分支与远程关联 1git push --set-upstream [origin master] #以后使用git push就可以了 如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。 1git push 指定push的默认远程主机 1git push -u [origin master]#以后再使用git push，即可。与第4点操作效果类似。 删除远程分支 1git push [origin] --delete [master]#删除origin/master分支 push所有本地分支到远程 1git push --all [origin] 覆盖远程分支 1git push --force [origin] #这是一个危险的命令，一般不要这么做 推送标签tag 1git push [origin] --tags 注：push时，如果远程有更新，会失败。需要先pull，或使用rebase模式；若有冲突，需要解决冲突。关于冲突见#merge fetch 获取remote最新信息拉取远程仓库上的所有新的信息。​12git fetch [remote-name] #如果只关联了一个远程仓库，可以不用显式指定远程仓库名​ -p选项与pull中的-p意义一样。 pull 拉取从远程获取最新版本并merge到本地 1.仅使用如下命令，表示拉取与当前分支关联的远程分支最新版本，并合并：1git pull 2.再比如，从远程仓库origin的newb分支，合并到master分支：1git pull [origin newb:master] #不写:master 表示与当前分支合并 3.使用–rebase选项1git pull --rebase [origin newb:master] #rebase模式pull 4.-p选项默认情况下，git pull 不会在拉取远程分支的时候，删除对应的本地分支。因为，可能其他人误删除了远程分支。如果要相应的在拉取时也删除本地对应分支：1git pull -p # pull时，可能有冲突，关于冲突见#merge reset、checkout 重置 HEADHEAD 是当前分支引用的指针，它总是指向该分支上的最后一次提交。 这表示 HEAD 将是下一次提交的父结点。 通常，理解 HEAD 的最简方式，就是将它看做 你的上一次提交 的快照。 撤销add例如，你已经修改了两个文件并且想要将它们作为两次独立的修改提交，但是却意外地输入了 git add * 暂存了它们两个。 如何只取消暂存两个中的一个呢？ git status 命令提示了你：​123456789$ git add *$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) renamed: README.md -&gt; README modified: CONTRIBUTING.md​ 提示中就说了，可以用如下命令来撤销某个add：​12$ git reset HEAD CONTRIBUTING.md​ 这样，并不会丢失 CONTRIBUTING.md 文件的修改。 –hard选项将当前分支，重置到某次提交(只要是reglog中存在的都可以)。​12git reset --hard 1a410efbd13591db07496601ebc7a059dd55cfe9​ 用checkout命令来重置提交或文件 重置文件如有一个已在版本记录中的文件a，现在做了修改，然后add，突然又觉得它的修改不需要了，想重置回到最近记录的样子，可用命令：​12git checkout [HEAD a] #HEAD指代最新提交，当然也可用SHA-1值。​ 如果将文件a恢复到上上个版本，只需要将HEAD换成上上个commit的SHA-1值。这时，通过git status，看到文件a被修改了，且自动add。 2.重置commit就是将当前分支重置到某次commit，同时会生成一个临时分支，并切换到这个临时分支上。​12git checkout [077d7ad] #commit记录：077d7ad ​ 如图：这里还提示你可以后跟 -b 新分支名，来从该commit检出一个新分支。 log 日志，提交历史查看提交历史1git log 会按提交时间列出所有的更新，最近的更新排在最上面。 这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明 –oneline选项 一行输出，只显示SHA-1 和 提交消息 1git log --oneline –all选项显示所有分支的历史记录 1git log —all -p选项 一个常用的选项是 -p，用来显示每次提交的内容差异(会输出diff差异)。 你也可以加上 -2 来仅显示最近两次提交：1git log -p -2 –stat选项 查看每次提交的简略的统计信息1git log --stat 比如，输出 –shortstat 只显示 –stat 中最后的行数修改添加移除统计 1git log --shortstat –name-only 仅在提交信息后显示已修改的文件清单。 1git log --name-only –name-status 显示新增、修改、删除的文件清单。 1git log --name-status –abbrev-commit 仅显示 SHA-1 的前几个字符(默认显示七个字符，不过有时为了避免 SHA-1 的歧义，会增加字符数)，而非所有的 40 个字符 1git log --abbrev-commit –graph显示 ASCII 图形表示的分支合并历史。 1git log --graph –pretty使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。 1git log --pretty= 如用 format，可以定制要显示的记录格式(format 常用的选项 )：1234$ git log --pretty=format:&quot;%h - %an, %ar : %s&quot;ca82a6d - Scott Chacon, 6 years ago : changed the version number085bb3b - Scott Chacon, 6 years ago : removed unnecessary testa11bef0 - Scott Chacon, 6 years ago : first commit –since, –after仅显示指定时间之后的提交(since和after都可以) 1git log --since=2.weeks #两周前的提交 这里用=或空格都可以 –until, –before仅显示指定时间之前的提交(until和before都可以) 1git log --before 2016-10-01 –author仅显示指定作者相关的提交。(作者指的是实际作出修改的人) 1git log --author [stone] –committer仅显示指定提交者相关的提交。(提交者指的是最后将此工作成果提交到仓库的人) 1git log --committer [zsan] –grep仅显示含指定关键字的提交 1git log --oneline --grep &quot;add&quot; 如，输出： -g选项这个命令会以标准日志的格式输出引用日志 1git log -g #后可跟分支名，若不跟，表示当前分支 提交区间 提交区间来解决 “这个分支还有哪些提交尚未合并到主分支？” 的问题。 1.双点 如，查看newb分支还有哪些提交未合并到master分支： 1git log master..newb#未被master包含的newb提交 如，查看当前分支即将推送到origin/master的内容：1git log origin/master..HEAD #HEAD可以留空，默认当前分支最新就是HEAD 2.多点 Git 允许你在任意引用前加上 ^ 字符或者 –not 来指明你不希望提交被包含其中的分支。因此下列3个命令是等价的：123git log refA..refBgit log ^master newb#查询不包含在master中的，newb提交信息git log newb --not master 这个语法很好用，因为你可以在查询中指定超过两个的引用，这是双点语法无法实现的。 比如，你想查看所有被 master 或 newb 包含的但是不被 newc 包含的提交，你可以输入下面中的任意一个命令：12git log master newb ^newcgit log master newb --not newc 3.三点查询两个引用中，被一个包含，但又不都包含的提交。1git log newb...newc 注：当要退出log视图，在冒号后，按q即可查看当前分支的commit记录。在reset 到历史版本后，git log命令是看不到新的提交记录的 查看分支引用如，你想要查看一个分支的最后一次提交的对象，假设 topic1 分支指向 ca82a6d ，那么以下的命令是等价的：​123git show ca82a6dff817ec66f44342007202690a93763949git show topic1​ 如，想要查看分支topic1，对应的完整SHA-1值：​12git rev-parse topic1​ 或，想要查看某个简写SHA-1值对应的完整值：​12git rev-parse ca82a6d​ 注：在使用简写SHA-1的commit引用时，最低4位 reflog 引用日志 当你正在工作时，Git 会默默地记录每一次你改变 HEAD 时它的值。 每一次你提交或改变分支，引用日志都会被更新1git reflog 类似输出：1234567734713b HEAD@&#123;0&#125;: commit: fixed refs handling, added gc auto, updatedd921970 HEAD@&#123;1&#125;: merge phedders/rdocs: Merge made by recursive.1c002dd HEAD@&#123;2&#125;: commit: added some blame and merge stuff1c36188 HEAD@&#123;3&#125;: rebase -i (squash): updating HEAD95df984 HEAD@&#123;4&#125;: commit: # This is a combination of two commits.1c36188 HEAD@&#123;5&#125;: rebase -i (squash): updating HEAD7e05da5 HEAD@&#123;6&#125;: rebase -i (pick): updating HEAD 每当你的 HEAD 所指向的位置发生了变化，Git 就会将这个信息存储到引用日志这个历史记录里。 通过这些数据，你可以很方便地获取之前的提交历史。 如果你想查看仓库中 HEAD 在五次前的所指向的提交，你可以使用 @{n} 来引用 reflog 中输出的提交记录： 12345git show HEAD@&#123;5&#125;git show master@&#123;3&#125; #查看master分支在前三次的的提交git show master@&#123;yesterday&#125;#查看昨天的git show HEAD@&#123;2.months.ago&#125;#查看2月前引用日志。#其它可用的时间值：years, months, days, hours, minutes, seconds 可以运行 git log -g 来查看类似于 git log 输出格式的引用日志信息 1git log -g master 类似输出：1234567commit 734713bc047d87bf7eac9674765ae793478c50d3Reflog: master@&#123;0&#125; (Scott Chacon &lt;schacon@gmail.com&gt;)Reflog message: commit: fixed refs handling, added gc auto, updatedAuthor: Scott Chacon &lt;schacon@gmail.com&gt;Date: Fri Jan 2 18:32:33 2009 -0800 fixed refs handling, added gc auto, updated tests 可以使用 HEAD^ 来查看上一个提交，也就是 “HEAD 的父提交”。 这个语法只适用于合并(merge)的提交，因为合并提交会有多个父提交。 第一父提交是你合并时所在分支，而第二父提交是你所合并的分支。 如下的例子，当前分支提交了6b43d14、467e8c1，合并其他分支的提交2aef572，合并后的提交为6f12bbc。通过git log --pretty=format:&#39;%h %s&#39; --graph查看log :12345678910111213141516171819* 6f12bbc 合并了|\ | * 2aef572 CC* | 467e8c1 AA* | 6b43d14 write newbbb|/ * 6772a20 newccc* d1a41a8 newc* db4f9bb newm* 6af9641 2update a* 0211e59 merge a|\ | * 9024fe6 update a* | 317888e modifyd a|/ * 1912753 update a* c7fcd00 upupup:* 077d7ad add aa* 2a518c5 aaffff 输入命令git show HEAD^，则会输出第一父提交467e8c1的提交信息输入命令git show HEAD^2，则会输出第二父提交2aef572的提交信息 可以使用 HEAD~ 来查看上一个提交。 git show HEAD^和git show HEAD~作用是等价的。 但后面跟上数字的作用就不一样了。~ 只算当前分支的父提交123git show 6f12bbc~2 #输出6b43d14引用git show 6f12bbc~8 #输出317888e引用git show 6f12bbc~7^2 #当前第7父提交的第2父，即输出9024fe6 merge 合并分支 列出是否合并到当前分支的分支 1.已经合并到当前分支的分支​12git branch --merged​ 2.尚未合并到当前分支的分支​12git branch --no-merged​ 分支合并要记住的一点是，以当前分支，来merge其他分支。​12git merge [otherBranch]#当前分支合并otherBranch分支​ Git 会自行决定选取哪一个提交作为最优的共同祖先，并以此作为合并的基础。 分支合并引发冲突有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们，那就会引发冲突conflict。例如，在master分支和newb分支，都修改了a文件，并提交了。现在想以master来合并newb分支。​12345$ git merge newbAuto-merging aCONFLICT (content): Merge conflict in aAutomatic merge failed; fix conflicts and then commit the result.​ 提示说a文件有冲突。当有冲突后，通过git status命令，看到：​12345678910On branch masterYou have unmerged paths. (fix conflicts and run &quot;git commit&quot;) (use &quot;git merge --abort&quot; to abort the merge)Unmerged paths: (use &quot;git add &lt;file&gt;...&quot; to mark resolution) both modified: a​ 现在打开a文件，看到：​123456&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADaawww=======adminwww&gt;&gt;&gt;&gt;&gt;&gt;&gt; newb​ &lt;&lt;HEAD和==间的就是当前master分支上的内容；==和&gt;&gt;间的就是newb分支上的内容。现在，只需手动清除不需要的内容(含这些说明字符)后，再add、commit即可。 合并工具如果你想使用图形化工具来解决冲突，可以运行 git mergetool，该命令会为你启动一个合适的可视化合并工具，并带领你一步一步解决这些冲突。如果没有打开工具，根据提示，输入git mergetool --tool-help，会列出本地已支持的工具列表，和支持的其他工具列表(需要自行安装)。比如，我这里本地支持opendiff工具，然后需要配置一下：​12git config --local merge.tool opendiff​ rebase 变基合并分支变基的大意就是指，指定基分支(紧跟在rebase后)，然后与指定分支分并。这时git会查询出两个分支共同的祖先，以基分支为基础，将要合并分支的commit取消掉，在 .git/rebase-apply/ 下生成一个patch文件。然后自动apply。(这里说的有点绕，看下面的命令后的注释，比较好理解) 123456#合并newb分支，newb为基，当前分支的新commit续到newb后，最终影响当前分支git rebase [newb] #newb分支为基，master中的变更，被续到newb后，最终影响master分支#这样跟先切换到master分支，再使用上面的reabse命令，效果一样git rebase [newb master] 变基使得提交历史更加整洁。你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的，但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。通过git log --graph图标式查看log，就能看到有些commit有分叉，那就是使用的merge方式进行合并了。 rebase引发冲突当解决了一个冲突，需要用”git-add”命令去更新这些内容的索引(index)，然后使用如下命令，继续应用下一个补丁。当所有冲突都解决了，也使用它，从而完成合并。1git rebase --continue 当想跳过patch，即只想要rebase分支内容，可用如下命令：1git rebase --skip 中断rebase合并操作：1git rebase --abort –onto选项 这个是应用在有三个分支的合并场景的。 如：1git rebase --onto [master server client] 表示：以master为基，找出server、client在master上的共同祖先之后的修改，只将符合条件的client修改进行应用。最后被修改的分支为client，server只是起到一个组合查询的作用。 变基的风险：不要对在你的仓库外有副本的分支执行变基。如，你push了c3、c4、c5三个提交；然后被其他同事pull应用后；你又使用rebase模式，合并了一个分支newb，若它们的共同祖先是c2，则c3、c4、c5就会先取消，后被重新应用并commit到newb分支的末尾。接着你再push，那么c3、c4、c5又会push一次。这时，其他人若要pull，要使用git pull –rebase 只要你把变基命令当作是在推送前清理提交使之整洁的工具，并且只在从未推送至共用仓库的提交上执行变基命令，就不会有事 其它参见 Git-工具-重写历史。里面有有意思的选项为：filter-branch bisect 二分查找记录比如有一个bug，不知道哪个历史提交引起的。这时就可以用bisect相关命令来查找。该命令采用二分法查找 开始查找：​12 git bisect start​ 使用git log，能看到提交记录(如要用到，可以只取前7位)，通过从提交记录检出成新分支或git reset方式，再运行调试，查看bug是否存在。最好是重新拉一个新的项目仓库下来，专门来做这个调试工作。 当确认bug存在时，标记找到问题：​12git bisect good 33f4b9e #在33f4b9e提交记录中，有问题​ 接着再找一个相对较早一些的提交记录(自己评估下)，运行、调试。若存在bug，操作同上。若不存在，标记未找到问题：​12git bisect bad 0a94086 #在0a94086提交记录中，未找到​ 当至少有一个bad和一个good后，就会提示，大概还需要多少次就能定位到问题了：​12Bisecting: 12 revisions left to test after this (roughly 4 steps)​ 大意：中间还有12个版本，大概最多还要4次测试，就能定位到问题了。 注：文末引用文章中，把没有问题的标记为good，有问题的才标记为bad。这里的示例，是将有问题的标记为good，没有问题的标记为bad。 blame 责任查找这个命令可以将文件中的每一行的作者、最新的变更提交和提交时间展示出来。1git blame [file_name] diff 比较文件改动差异 比较未暂存文件改动差异比如一个已add的文件，经过改动后，尚未再次add，输入命令：​12git diff​ 如图：比较SpacePresenter 最新版本记录(-)和当前改动(+)后，文件间的差异 比较已暂存文件改动差异​123git diff --cached git diff --staged #功能同cached。 git1.6.1及更高版可用 ​ 比较文件的前后差异。可以通过GUI工具来查看，show differenceGit Diff 的插件版本可以使用 git difftool 命令来用 Araxis ，emerge 或 vimdiff 等软件输出 diff 分析结果。 使用 git difftool –tool-help 命令来看你的系统支持哪些 Git Diff 插件。 如需要配置请使用 git config --global diff.tool Araxis patch 补丁如果项目，只有你一个人在维护。其他人想要commit、push是不行的。但他们clone下来项目，经过修改后，可以生成并发送一个patch给你，让你来合并代码。用到的命令：git format-patch #生成patch文件git apply xxx.patch #应用patch 注：由于没有完全试验过，这里说的比较简略 remote 远程仓库如果是从远程仓库检出的项目，可以直接输入命令：​12git remote​ 至少能看到类似 origin 的输出。origin是一般默认的远程仓库名。 -v选项会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。​12git remote -v​ 如，输出：​123origin https://github.com/googlesamples/android-architecture.git (fetch)origin https://github.com/googlesamples/android-architecture.git (push)​ fetch，是客户端拉取最新信息的地址；push就是上传的地址。 add选项添加一个新的远程 Git 仓库，同时指定一个你可以轻松引用的简写：​12git remote add [pb https://github.com/paulboone/ticgit]​ 如上，pb就是指定的远程仓库简写。再用-v命令查看：​123456$ git remote -vorigin https://github.com/schacon/ticgit (fetch)origin https://github.com/schacon/ticgit (push)pb https://github.com/paulboone/ticgit (fetch)pb https://github.com/paulboone/ticgit (push)​ 现在，就关联了两个远程仓库地址了。在fetch或push时，可以指定远程仓库名，如：​123git push [pb master] # push到远程仓库pb上的master分支git fetch [pb] # fetch远程仓库pb上所有新的信息​ show选项​12git remote show [origin]​ 会输出fetch、push的url，当前所在分支，不在本地的远程分支，哪些远程分支已经从服务器上移除了，还有pull和push时本地与远程分支的关联 rename选项重命名引用的远程仓库名字​12git remote rename [pb paul]​ rm选项删除远程仓库引用。​12git remote rm [paul] #rm 换成 remove也是可以的​ git远程删除分支后，本地git branch -a 依然能看到，需要修整：​12git remote prune [origin] //修整远程origin仓库​ 比如远程删除的是optimize分支，命令运行后会输出 * [pruned] origin/optimize clean 清理工作目录你需要谨慎地使用这个命令，因为它被设计为从工作目录中移除未被追踪的文件。 如果你改变主意了，你也不一定能找回来那些文件的内容。 一个更安全的选项是运行 git stash --all 来移除每一样东西并存放在栈中。 可以使用git clean命令去除冗余文件或者清理工作目录。 使用git clean -f -d命令来移除工作目录中所有未追踪的文件以及空的子目录。 -f 意味着 强制 或 “确定移除”。 如果只是想要看看它会做什么，可以使用 -n 选项来运行命令，这意味着 “做一次演习然后告诉你 将要 移除什么”。1git clean -d -n 输出：12Would remove test.oWould remove tmp/ 默认情况下，git clean 命令只会移除没有忽略的未跟踪文件。 任何与 .gitiignore 或其他忽略文件中的模式匹配的文件都不会被移除。 如果你也想要移除那些文件，例如为了做一次完全干净的构建而移除所有由构建生成的 .o 文件，可以给 clean 命令增加一个 -x 选项。1git clean -n -d -x 如果不知道 git clean 命令将会做什么，在将 -n 改为 -f 来真正做之前，总是先用 -n 来运行它做双重检查。 Git 打包Git 工具 - 打包 使用GitHub上的开源项目 当clone好项目后，可以建立自己的本地分支，进行调试等。这样方便，以后合并项目某个分支，主分支单独更新等。 对项目做出贡献 Git 与其他系统 迁移到 Git Git 验证Git 工具 - 签署工作用到gpg工具，这个需要单独安装，并配置环境 Reference https://git-scm.com/book/zh/v2/ 《官方指南》http://www.cnblogs.com/haiq/archive/2012/12/26/2833746.html 《ignore语法》http://www.cnblogs.com/wish123/p/3963224.html 《diff命令详解》http://gitbook.liuhui998.com/5_4.html 《查找问题的利器 - Git Bisect》http://www.oschina.net/translate/10-tips-git-next-level 《10 个迅速提升你 Git 水平的提示》http://www.ruanyifeng.com/blog/2014/06/git_remote.html 《Git远程操作详解》]]></content>
      <categories>
        <category>版本控制</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
